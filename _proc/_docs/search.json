[
  {
    "objectID": "use.html",
    "href": "use.html",
    "title": "cylinder",
    "section": "",
    "text": "Use the model in repeatable conditions to estabish different patterns from operation\nLoad some representative wholesale power price data\nEstablish some operational parameters and control strategies\nSet a function to run the different strategies operating on the thermostat as this is all that the strategy can effectively control\n\n# Initialize an empty dictionary\nstrategies = {}\n\n# Add some keys and values to the dictionary\n# stategies[0] = 'description1'    \nstrategies[0] = {'name': 'Baseline case: current operation with ripple control',\n                'operation': 'continuous',\n                'bedrooms': 4,\n                'element' :3,\n                'Tset_H' : 60,\n                'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n                'ripple' : True}\nstrategies[1] = {'name':'Baseline case: current operation with no ripple control',\n            'operation': 'off_peak',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 60,\n            'Tset_L' : 60,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : False}\nstrategies[2] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n            'ripple' : False}\nstrategies[3] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3.6,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n                'radius' : 0.3,\n                'height' : 1.4,\n            'ripple' : False}\nstrategies[4] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 70,\n            'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n            'ripple' : False}\n\nAdd functionality for a thermostat\n\ndf = {} \ntime_period = '2020-06'\npower = load_power(path = Path('../data/'), ripple_control=True)#/home/cjp/cylinder/data/powerprices.csv\nfor strategy in strategies:\n    env = HWC(T_set=strategies[strategy]['Tset_H'], \n              radius=strategies[strategy]['radius'],\n              height=strategies[strategy]['height'],\n              element=strategies[strategy]['bedrooms'],\n              U=.8)\n    temp = []\n    flow = load_demand(path = Path('../data/drawprofiles'),\n                      bed=strategies[strategy]['bedrooms'],\n                      unit=3).loc[:,'flow']\n    for row in power.loc[time_period].itertuples(): # go through a set time period\n        action = 0\n        pwr = [1,1]\n        \n        # adjust for temperature\n        env._thermostat()\n        # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n        if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n            if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = ~row.peak\n            elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = 1\n            elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.costrank_8h < 0.2 else 0\n\n                pwr = [0,1]\n\n\n        if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n            action = 1\n        \n\n        if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n            action = 0\n            pwr[1] = 0 # no power to the element\n\n        env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n        temp.append([strategy,\n                    action,\n                    row.ripple_control * strategies[strategy]['ripple'] ,\n                    *env.thermostat.copy(),\n                    *env.temperatures.copy(),\n                    env.z,\n                    env.volume])\n    tmp = pd.DataFrame(temp, \n                            columns=['strategy',\n                                     'action',\n                                     'ripple_control_demand',\n                                     'thermostat_high',\n                                     'thermostat_base',\n                                     'T0',\n                                     'T1',\n                                     'z',\n                                     'volume'])\n    df[strategy] = pd.concat([power.loc[time_period].reset_index(),\n                flow.loc[time_period].reset_index(drop=True),\n                tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\n\n\nfor n in range(5):\n    plot_sim(strategies[n], df[n].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = []\nfor n, sim in enumerate(df):\n    t_mean = (0.7*df[n].T0.mean()+ 0.3*df[n].T1.mean())\n    peak_demand = (df[n].peak*strategies[n][\"element\"]*df[n].action).sum()/len(df[n])\n    # print(f'demand at peak : {100*peak_demand:.2f}%')\n    local_kwh = (df[n].action*strategies[n][\"element\"]/60*df[n].thermostat_base*(df[n].ripple_control!=1)).sum()\n    remote_kwh = (df[n].action*strategies[n][\"element\"]/60*df[n].thermostat_high*(df[n].thermostat_base!=1)).sum()\n    # print(f'Local kWh : {local_kwh:.2f}',end=' ')\n    # print(f'Remote kWh : {remote_kwh:.2f}')\n    local_cost = (df[n].cost*strategies[n][\"element\"]/60*df[n].action*df[n].thermostat_base).sum()\n    remote_cost = (df[n].cost*strategies[n][\"element\"]/60*df[n].action*df[n].thermostat_high*(df[n].thermostat_base!=1)).sum()\n    # print(f'Local Cost : {local_cost/local_kwh:.2f}',end=' ')\n    # print(f'Remote Cost : {remote_cost/remote_kwh:.2f}')\n\n    loss_of_service = 100*(df[n].T0<55).sum()/len(df[n])\n    days = (df[0].iloc[-1].name-df[0].iloc[0].name).days\n    # print(f'Days : {days:.2f}')    \n    # print(f'Loss of Service : {100*loss_of_service:.2f}%')    \n    data.append([*strategies[n].values(),\n                 df[n].iloc[0].name,\n                 df[n].iloc[-1].name,\n                 df[n].volume.mean()*1000,\n                 peak_demand,\n                 local_kwh,\n                 remote_kwh,\n                 local_kwh+remote_kwh,\n                 local_cost,\n                 remote_cost,\n                 local_cost+remote_cost,\n                 t_mean,\n                 loss_of_service])\nsummary = pd.DataFrame(data,columns=list(strategies[0].keys())+['start_time', 'end_time', 'volume','peak_demand', 'local_kwh', 'remote_kwh', 'total_kwh', 'local_cost', 'remote_cost', 'total_cost', 't_mean', 'loss_of_service'])\nsummary['peak_reduction'] = 100*(summary.peak_demand-summary.loc[0,'peak_demand'])/summary.loc[0,'peak_demand']\nsummary['cost_reduction'] = 100*(summary.total_cost-summary.loc[0,'total_cost'])/summary.loc[0,'total_cost']\n\n\nsummary.T\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      name\n      Baseline case: current operation with ripple c...\n      Baseline case: current operation with no rippl...\n      Split Control: remote operation on price signa...\n      Split Control: remote operation on price signa...\n      Split Control: remote operation on price signa...\n    \n    \n      operation\n      continuous\n      off_peak\n      price\n      price\n      price\n    \n    \n      bedrooms\n      4\n      4\n      4\n      4\n      4\n    \n    \n      element\n      3.0\n      3.0\n      3.0\n      3.6\n      3.0\n    \n    \n      Tset_H\n      60\n      60\n      75\n      75\n      70\n    \n    \n      Tset_L\n      60\n      60\n      60\n      60\n      60\n    \n    \n      radius\n      0.22\n      0.22\n      0.22\n      0.3\n      0.22\n    \n    \n      height\n      1.1\n      1.1\n      1.1\n      1.4\n      1.1\n    \n    \n      ripple\n      True\n      False\n      False\n      False\n      False\n    \n    \n      start_time\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n    \n    \n      end_time\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n    \n    \n      volume\n      167.258393\n      167.258393\n      167.258393\n      395.840674\n      167.258393\n    \n    \n      peak_demand\n      0.22\n      0.229931\n      0.137083\n      0.105333\n      0.158194\n    \n    \n      local_kwh\n      301.9\n      292.95\n      141.75\n      107.7\n      167.75\n    \n    \n      remote_kwh\n      0.0\n      0.0\n      136.3\n      282.12\n      117.75\n    \n    \n      total_kwh\n      301.9\n      292.95\n      278.05\n      389.82\n      285.5\n    \n    \n      local_cost\n      73.782102\n      75.731868\n      40.302617\n      31.663776\n      47.431951\n    \n    \n      remote_cost\n      0.0\n      0.0\n      19.244775\n      39.456843\n      16.580938\n    \n    \n      total_cost\n      73.782102\n      75.731868\n      59.547392\n      71.120619\n      64.012889\n    \n    \n      t_mean\n      58.963058\n      59.060973\n      70.199214\n      70.702455\n      65.860602\n    \n    \n      loss_of_service\n      1.208333\n      0.87963\n      0.0\n      0.0\n      0.113426\n    \n    \n      peak_reduction\n      0.0\n      4.513889\n      -37.689394\n      -52.121212\n      -28.093434\n    \n    \n      cost_reduction\n      0.0\n      2.642601\n      -19.292904\n      -3.60722\n      -13.240627"
  },
  {
    "objectID": "hwc_2node.html",
    "href": "hwc_2node.html",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "",
    "text": "In order to simulate aleternative control strategies a hot water cylinder environment that approximates the operation under real world conditions is required. There are a large number of models of varying numerical complexity that were reviewed such as:\nModel Predictive Control of Heat Pump Water Heaters for Energy Efficiency\nDynamic modeling of a sensible thermal energy storage tank with an immersed coil heat exchanger under three operation modes\nThese models have been developed to incorporate stratification and internal heat transfer however a simple energy balance model was selected with the addition of an internal conduction variable to decay the stratified layer.\nA minimal simulation of the electricity demand of a domestic hot water cylinder for smart control\n\\(\\Delta \\quad\\) internal heat transfer scaling parameter\n\\(\\dot{m}_{c} \\quad\\) mass flow rate of IHX coil fluid\n\\(\\dot{m}_{c w} \\quad\\) mass flow rate of inlet domestic cold water\n\\(\\dot{m}_{t} \\quad\\) discharge mass flow rate through tank\n\\(\\dot{Q}_{\\text {coil }} \\quad\\) heat transfer rate due to IHX coil\n\\(\\dot{Q}_{j+1}\\) heat transfer rate between nodes \\(j\\) and \\(j+1\\)\n\\(\\dot{Q}_{j-1} \\quad\\) heat transfer rate between nodes \\(j\\) and \\(j-1\\)\n\\(\\dot{Q}_{\\text {wall }}\\) heat transfer rate for losses to surroundings\nA cross-sectional area of node control volume\n\\(A_{w} \\quad\\) wall contact surface area\n\\(c_{v} \\quad\\) specific heat capacity of water\n\\(j \\quad\\) current node in iterative energy equations\n\\(j+1 \\quad\\) represents node below node \\(j\\)\n\\(\\begin{array}{ll}j-1 & \\text { represents node above node } j \\\\ k & \\text { internal node interaction heat transfer coefficient } \\\\ k_{w} & \\text { lumped heat transfer coefficient for losses across walls } \\\\ m & \\text { mass of node } \\\\ s_{1} & \\text { discharge fluid correction factor } \\\\ T & \\text { temperature } \\\\ t & \\text { time } \\\\ T_{c w} & \\text { domestic cold water temperature } \\\\ T_{e n} & \\text { IHX coil fluid inlet temperature } \\\\ T_{e x} & \\text { IHX coil fluid outlet temperature } \\\\ w_{t} & \\text { tank wall thickness } \\\\ z & \\text { vertical height variable with respect to tank bottom }\\end{array}\\)\nsource"
  },
  {
    "objectID": "hwc_2node.html#initialisation",
    "href": "hwc_2node.html#initialisation",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "Initialisation",
    "text": "Initialisation\n\ntemp = []\nfor i in range(10):\n    env = HWC(T_set=75, element=3)\n    temp.append(env.temperatures)\n    assert env.temperatures[0]<= 75.5\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nfig.suptitle('Random initial states of charge for 10 different models')\n\nText(0.5, 0.98, 'Random initial states of charge for 10 different models')\n\n\n\n\n\n\nenv = HWC(T_set=75, element=3, height=1, radius=.5)\n# check that the volume and areas are correct\nassert env.volume == np.pi/4\nassert env.A == np.pi/4"
  },
  {
    "objectID": "hwc_2node.html#passive-losses---no-heating-no-flow",
    "href": "hwc_2node.html#passive-losses---no-heating-no-flow",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "Passive Losses - No Heating + No Flow",
    "text": "Passive Losses - No Heating + No Flow\n\nenv = HWC(T_set=55, element=3, radius=.25, U=1)\ntemp = []\nminutes = 60*24\nfor minute in range(minutes):\n    env._update_model(action = 0 , flow = 0)\n    temp.append(env.temperatures)\n\n\nCompare to calulation from first principles\n\nmean_cylinder_temperature = (np.vstack(temp)* env.split).sum(axis=1).mean()\npassive_real =   env.U * env.surface_area * (mean_cylinder_temperature - env.T_ambient) # kW/m2K x m2 x K  = KW\npassive_real =   passive_real * 60 * 24 / 1000 # kWh per day\n\nmodel_losses =   env.volume * env.ρ * env.Cv * ((temp[0]* env.split).sum()- (temp[-1]* env.split).sum()) / 1000 \nprint(f'Calculated Passive losses: {passive_real/24:.2f} kWh / hour and a total of {passive_real:.2f} kWh / day')\n\nprint(f'Model Losses:  minutes {model_losses:.2f} kWh / hour and a total of {model_losses:.2f} kWh / day')\n\nCalculated Passive losses: 0.08 kWh / hour and a total of 1.85 kWh / day\nModel Losses:  minutes 0.00 kWh / hour and a total of 0.00 kWh / day\n\n\n\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nax.plot((np.vstack(temp)*env.split).sum(axis=1), lw=2, ls=':', c='blue')\nfig.suptitle(f'Passive Losses - No Heating + No Flow over {minutes} minutes')\n\nText(0.5, 0.98, 'Passive Losses - No Heating + No Flow over 1440 minutes')\n\n\n\n\n\nThe standing heat loss for a tank should be in the order of 1.7 kWh / day for a tank at 55 degrees. https://sustainableengineering.co.nz/portfolio-item/dhw-tanks-w-k-from-kwh-day/"
  },
  {
    "objectID": "hwc_2node.html#no-heating-flow-rate-of-10-litres-per-minure-for-10-minutes",
    "href": "hwc_2node.html#no-heating-flow-rate-of-10-litres-per-minure-for-10-minutes",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "No Heating + Flow rate of 10 litres per minure for 10 minutes",
    "text": "No Heating + Flow rate of 10 litres per minure for 10 minutes\n\nenv = HWC(T_set=75, element=3)\nflow = 10/60/1000 # 10 litres per minute\ntemp = []\nminutes = 60\nfor minute in range(minutes):\n    action = 0 #np.random.randint(0,2)\n    env._update_model(action = action , flow = flow if minute < 10 else 0)\n    temp.append(env.temperatures.copy())\n\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nax.plot((np.vstack(temp)*env.split).sum(axis=1), lw=2, ls=':', c='blue')\n\nfig.suptitle('No Heating + Flow rate of 10 litres per minure for 10 minutes')\n\nText(0.5, 0.98, 'No Heating + Flow rate of 10 litres per minure for 10 minutes')"
  },
  {
    "objectID": "ripple_control.html",
    "href": "ripple_control.html",
    "title": "New Zealand Ripple Control",
    "section": "",
    "text": "Ripple control statistices to modify the real operation\nRipple control is a technology that is used to manage the supply of electricity in residential hot water cylinders in New Zealand. This technology allows utility companies to remotely control the electricity supply to hot water cylinders, ensuring that electricity is used efficiently and cost-effectively.\nOne of the key benefits of ripple control is that it allows utility companies to manage the demand for electricity during peak periods. By limiting the amount of electricity that is supplied to hot water cylinders during these times, the utility company can help to prevent power outages and ensure that electricity is available to meet the needs of other customers.\nOverall, ripple control is a useful technology that can help to manage the supply of electricity to residential hot water cylinders in New Zealand. By allowing utility companies to control the electricity supply, ripple control can help to prevent power outages, reduce electricity bills, and protect the environment.\nA 2020 research paper by EECA reviews the current state and operation of the ripple control network.\nDetails of ripple control used for load management are detailled on the Orion Network\n\ndf = pd.read_excel('../data/orion_rc.xlsx', skiprows=11)\ndf = df.dropna(axis=1, how='all').iloc[:,:3]#.set_index('Date')\ndf.columns = ['Date', 'max_off', 'max_ave_off']\ndf = df.set_index('Date')\n# convert h:m:s to seconds\ndf['max_off'] = pd.to_datetime(df['max_off'], format='%H:%M:%S')\ndf['max_ave_off'] = pd.to_datetime(df['max_ave_off'], format='%H:%M:%S')\ndf = df.assign(max_off = lambda x: x['max_off'].dt.hour*60 + x['max_off'].dt.minute + x['max_off'].dt.second/60,\n          max_ave_off = lambda x: x['max_ave_off'].dt.hour*60 + x['max_ave_off'].dt.minute + x['max_ave_off'].dt.second/60,\n          day = lambda x: x.index.dayofweek,\n          month = lambda x: x.index.month,\n          weekday = lambda x: x.index.weekday<5,\n          season = lambda x: x.index.map(get_season))\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      max_off\n      max_ave_off\n      day\n      month\n      weekday\n      season\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2012-05-01\n      74.0\n      17.0\n      1\n      5\n      True\n      Autumn\n    \n    \n      2012-05-02\n      41.0\n      31.0\n      2\n      5\n      True\n      Autumn\n    \n    \n      2012-05-03\n      41.0\n      31.0\n      3\n      5\n      True\n      Autumn\n    \n    \n      2012-05-16\n      70.0\n      54.0\n      2\n      5\n      True\n      Autumn\n    \n    \n      2012-05-17\n      70.0\n      54.0\n      3\n      5\n      True\n      Autumn\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      2022-10-14\n      19.0\n      1.0\n      4\n      10\n      True\n      Spring\n    \n    \n      2022-10-18\n      30.0\n      16.0\n      1\n      10\n      True\n      Spring\n    \n    \n      2022-10-19\n      45.0\n      32.0\n      2\n      10\n      True\n      Spring\n    \n    \n      2022-10-20\n      20.0\n      8.0\n      3\n      10\n      True\n      Spring\n    \n    \n      2022-10-25\n      24.0\n      8.0\n      1\n      10\n      True\n      Spring\n    \n  \n\n1030 rows × 6 columns\n\n\n\nThere is a large variation in frequency based on the season\n\n# do a histogram plot of the max_average_off grouped by season and if the day was a week day or weekend as 4 separate subplots (one for each season)\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\nbins = np.linspace(0, 300, 15)\n\nfor i, season in enumerate(df['season'].unique()):\n    ax = axes[i//2, i%2]\n    t = np.linspace(0, 300, 100)\n    # df[df['season'] == season].groupby('weekday')['max_ave_off'].plot(kind='hist', ax=ax, alpha=0.5, bins=bins, legend=True)\n    print(season,\n            df[(df.season == season)&(df['weekday']==True)].max_ave_off.mean(), \n            df[(df.season == season)&(df['weekday']==True)].max_ave_off.std(),skew(df[(df.season == season)&(df['weekday']==True)].max_ave_off))\n    ax.hist([df[(df.season == season)&(df['weekday']==True)].max_ave_off,\n             df[(df.season == season)&(df['weekday']==False)].max_ave_off],\n             bins=bins, alpha=0.5, label=['weekday','weekend'])\n    ax.set_title(season)\n    ax.set_xlabel('max average off (min)')\n    ax.set_ylabel('frequency')\n    ax.set_ylim(0, 130)\n\n    ax.legend()\nplt.tight_layout()\nfig.suptitle('Frequency plot of Ripple Control \\nin the Orion Network 2012-2022 :max_ave_off minutes by season', fontsize=16, y=1.05)\n\nplt.show()\n\nAutumn 44.92028985507246 52.35728765624028 1.985906057501679\nWinter 70.12273641851107 61.136638232997406 1.205216062727588\nSpring 49.46829268292683 60.15001849552464 1.7514057414449147\nSummer 51.98360655737705 79.70327031735863 1.7129228895001667"
  },
  {
    "objectID": "power.html",
    "href": "power.html",
    "title": "Real Time Power Prices",
    "section": "",
    "text": "Electricity pricing data is sourced from the Electricity Authority.\nThe data aims to provide a real signal that can be used to interact with the hot water model simulation. In some cases this data is used as a proxy for the carbon content of the generated electricity. This is not a perfect proxy, but it is a reasonable one.\n\nsource\n\nload_power\n\n load_power (path=None, ripple_control=False)\n\nReturn power price\n\ndf = load_power(path = Path('../data/'), ripple_control=True)\ndf\n\n\n\n\n\n  \n    \n      \n      price\n      ripple_control\n      price_kw\n      date\n      week\n      season\n      hour\n      day\n      peak\n      tou\n      cost\n      n_cost\n      sr_cost\n      lr_cost\n      costrank_6h\n      costrank_8h\n      costrank_12h\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-01-01 11:59:00\n      21.858\n      False\n      0.021858\n      2020-01-01\n      1\n      Summer\n      11\n      2\n      0\n      0.02\n      0.041858\n      -0.08142\n      0.163122\n      0.151413\n      0.302778\n      0.477083\n      0.651389\n    \n    \n      2020-01-01 12:00:00\n      21.860\n      False\n      0.021860\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.041860\n      -0.08140\n      0.162465\n      0.151270\n      0.318056\n      0.488542\n      0.659028\n    \n    \n      2020-01-01 12:01:00\n      22.230\n      False\n      0.022230\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042230\n      -0.07770\n      0.160373\n      0.149827\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:02:00\n      22.600\n      False\n      0.022600\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042600\n      -0.07400\n      0.158294\n      0.148426\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:03:00\n      22.970\n      False\n      0.022970\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042970\n      -0.07030\n      0.156227\n      0.147066\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      2020-12-31 21:51:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.181917\n      0.194701\n      0.018056\n      0.013542\n      0.009028\n    \n    \n      2020-12-31 21:52:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182253\n      0.194996\n      0.019444\n      0.014583\n      0.009722\n    \n    \n      2020-12-31 21:53:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182548\n      0.195280\n      0.020833\n      0.015625\n      0.010417\n    \n    \n      2020-12-31 21:54:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182802\n      0.195554\n      0.022222\n      0.016667\n      0.011111\n    \n    \n      2020-12-31 21:55:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.183015\n      0.195817\n      0.023611\n      0.017708\n      0.011806\n    \n  \n\n526197 rows × 17 columns\n\n\n\n\nfig, ax = plt.subplots(nrows=2, figsize=(12,6), sharex=True)\nax[0].plot(df.loc['2020-01-01'].cost)\nax[0].set_ylabel('$/kWh')\nax[0].set_title('Wholesale Electricity Price')\nax[1].plot(df.loc['2020-01-01'].sr_cost)\n# set ax[1] x axis labels to HH:MM\n# set this formatter to the axis\n# ax[1].xaxis.set_major_formatter(fmtr)\nax[1].xaxis.set_major_formatter(mdates.DateFormatter(\"%H:%M\"))\nax[1].xaxis.set_minor_formatter(mdates.DateFormatter(\"%H:%M\"))"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\nget_season\n\n get_season (date)\n\n\nsource\n\n\nseries_timestamps\n\n series_timestamps (ser)\n\n\nsource\n\n\nplot_sim\n\n plot_sim (strategy, df)"
  },
  {
    "objectID": "demand.html",
    "href": "demand.html",
    "title": "Sample Demand Profile",
    "section": "",
    "text": "There are some 1 minute draw profiles for US domestic hot water. The data is from the BEopt. The data requires some cleaning and processing. This data is used to provide input into the model.\n\nsource\n\nload_demand\n\n load_demand (path=None, bed=1, unit=1)\n\n\nflow = load_demand(path = Path('../data/drawprofiles'),\n                      bed=4,\n                      unit=3)\nflow.head()\n\n\n\n\n\n  \n    \n      \n      Showers\n      Sinks\n      CW\n      DW\n      Baths\n      total_lpm\n      total_m3s\n      flow\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-01-01 00:00:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:01:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:02:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:03:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:04:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n\n\n\nLook at one days worth of data for the chosen unit and number of bedrooms.\n\n# fig, ax = plt.subplots(figsize=(12,6))\n# ax.plot(flow['2020-01-01'])\n# ax.set_ylabel('Flow (m3/s)')\n# ax.set_xlabel('Time')\n# ax.set_title('Flow for 2 bed 3 unit')\n\n\nfig, ax = plt.subplots(figsize=(16,6))\n\nax.imshow(flow.groupby([flow.index.hour, flow.index.day_of_week])['flow'].mean().unstack().T*3600, cmap='hot', interpolation='nearest')\nax.set_xlabel('Hour of Day')\nax.set_ylabel('Day of Week')\nfig.suptitle('Average Flow')\n# add colorbar\nfig.colorbar(ax.get_images()[0], ax=ax)\n\n<matplotlib.colorbar.Colorbar>"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cylinder",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cylinder",
    "section": "Install",
    "text": "Install\npip install cylinder\nThis basic model provides the core function for a step change calculation in a mixed hot water cylinder"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "cylinder",
    "section": "How to use",
    "text": "How to use\nLoad some data that can be used to test the model - flow and electricity pricing\n\n# df = (pd.DataFrame(load_demand(path = Path('../data/drawprofiles'),bed=5,unit=4)))\n# df.columns=[\"flow\"]\n# df = df.merge(load_power(path = Path('../data')), how='left', left_index=True, right_index=True)\n# df.head()\n\nCreate a hot water cylinder object and initialise it with the data\n\nhwc = HWC(T_set=70, T_deadband=2, element=3, radius=.2, height=1.5)\n\n\nprint(f'The HWC volume is {int(hwc.volume*1000)} liters')\nprint(f'The HWC surface area is {hwc.surface_area:.2f} m2')\nprint(f'The HWC has a {hwc.element:.2f} kW element')\n\nThe HWC volume is 188 liters\nThe HWC surface area is 2.14 m2\nThe HWC has a 3.00 kW element\n\n\nDefault thermogram\nRun the model for a single day on thermostat and plot the results"
  },
  {
    "objectID": "05_use.html",
    "href": "05_use.html",
    "title": "cylinder",
    "section": "",
    "text": "Use the model in repeatable conditions to estabish different patterns from operation\nLoad some representative wholesale power price data\nEstablish some operational parameters and control strategies\nSet a function to run the different strategies operating on the thermostat as this is all that the strategy can effectively control\n\n# Initialize an empty dictionary\nstrategies = {}\n\n# Add some keys and values to the dictionary\n# stategies[0] = 'description1'    \nstrategies[0] = {'name': 'Baseline case: current operation with ripple control',\n                'operation': 'continuous',\n                'bedrooms': 4,\n                'element' :3,\n                'Tset_H' : 60,\n                'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n                'ripple' : True}\nstrategies[1] = {'name':'Baseline case: current operation with no ripple control',\n            'operation': 'off_peak',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 60,\n            'Tset_L' : 60,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : False}\nstrategies[2] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n            'ripple' : False}\nstrategies[3] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3.6,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n                'radius' : 0.3,\n                'height' : 1.4,\n            'ripple' : False}\nstrategies[4] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 70,\n            'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n            'ripple' : False}\n\nAdd functionality for a thermostat\n\ndf = {} \ntime_period = '2020-06'\npower = load_power(path = Path('../data/'), ripple_control=True)#/home/cjp/cylinder/data/powerprices.csv\nfor strategy in strategies:\n    env = HWC(T_set=strategies[strategy]['Tset_H'], \n              radius=strategies[strategy]['radius'],\n              height=strategies[strategy]['height'],\n              element=strategies[strategy]['bedrooms'],\n              U=.8)\n    temp = []\n    flow = load_demand(path = Path('../data/drawprofiles'),\n                      bed=strategies[strategy]['bedrooms'],\n                      unit=3).loc[:,'flow']\n    for row in power.loc[time_period].itertuples(): # go through a set time period\n        action = 0\n        pwr = [1,1]\n        \n        # adjust for temperature\n        env._thermostat()\n        # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n        if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n            if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = ~row.peak\n            elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = 1\n            elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.costrank_8h < 0.2 else 0\n\n                pwr = [0,1]\n\n\n        if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n            action = 1\n        \n\n        if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n            action = 0\n            pwr[1] = 0 # no power to the element\n\n        env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n        temp.append([strategy,\n                    action,\n                    row.ripple_control * strategies[strategy]['ripple'] ,\n                    *env.thermostat.copy(),\n                    *env.temperatures.copy(),\n                    env.z,\n                    env.volume])\n    tmp = pd.DataFrame(temp, \n                            columns=['strategy',\n                                     'action',\n                                     'ripple_control_demand',\n                                     'thermostat_high',\n                                     'thermostat_base',\n                                     'T0',\n                                     'T1',\n                                     'z',\n                                     'volume'])\n    df[strategy] = pd.concat([power.loc[time_period].reset_index(),\n                flow.loc[time_period].reset_index(drop=True),\n                tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\n\n\nfor n in range(5):\n    plot_sim(strategies[n], df[n].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndata = []\nfor n, sim in enumerate(df):\n    t_mean = (0.7*df[n].T0.mean()+ 0.3*df[n].T1.mean())\n    peak_demand = (df[n].peak*strategies[n][\"element\"]*df[n].action).sum()/len(df[n])\n    # print(f'demand at peak : {100*peak_demand:.2f}%')\n    local_kwh = (df[n].action*strategies[n][\"element\"]/60*df[n].thermostat_base*(df[n].ripple_control!=1)).sum()\n    remote_kwh = (df[n].action*strategies[n][\"element\"]/60*df[n].thermostat_high*(df[n].thermostat_base!=1)).sum()\n    # print(f'Local kWh : {local_kwh:.2f}',end=' ')\n    # print(f'Remote kWh : {remote_kwh:.2f}')\n    local_cost = (df[n].cost*strategies[n][\"element\"]/60*df[n].action*df[n].thermostat_base).sum()\n    remote_cost = (df[n].cost*strategies[n][\"element\"]/60*df[n].action*df[n].thermostat_high*(df[n].thermostat_base!=1)).sum()\n    # print(f'Local Cost : {local_cost/local_kwh:.2f}',end=' ')\n    # print(f'Remote Cost : {remote_cost/remote_kwh:.2f}')\n\n    loss_of_service = 100*(df[n].T0<55).sum()/len(df[n])\n    days = (df[0].iloc[-1].name-df[0].iloc[0].name).days\n    # print(f'Days : {days:.2f}')    \n    # print(f'Loss of Service : {100*loss_of_service:.2f}%')    \n    data.append([*strategies[n].values(),\n                 df[n].iloc[0].name,\n                 df[n].iloc[-1].name,\n                 df[n].volume.mean()*1000,\n                 peak_demand,\n                 local_kwh,\n                 remote_kwh,\n                 local_kwh+remote_kwh,\n                 local_cost,\n                 remote_cost,\n                 local_cost+remote_cost,\n                 t_mean,\n                 loss_of_service])\nsummary = pd.DataFrame(data,columns=list(strategies[0].keys())+['start_time', 'end_time', 'volume','peak_demand', 'local_kwh', 'remote_kwh', 'total_kwh', 'local_cost', 'remote_cost', 'total_cost', 't_mean', 'loss_of_service'])\nsummary['peak_reduction'] = 100*(summary.peak_demand-summary.loc[0,'peak_demand'])/summary.loc[0,'peak_demand']\nsummary['cost_reduction'] = 100*(summary.total_cost-summary.loc[0,'total_cost'])/summary.loc[0,'total_cost']\n\n\nsummary.T\n\n\n\n\n\n  \n    \n      \n      0\n      1\n      2\n      3\n      4\n    \n  \n  \n    \n      name\n      Baseline case: current operation with ripple c...\n      Baseline case: current operation with no rippl...\n      Split Control: remote operation on price signa...\n      Split Control: remote operation on price signa...\n      Split Control: remote operation on price signa...\n    \n    \n      operation\n      continuous\n      off_peak\n      price\n      price\n      price\n    \n    \n      bedrooms\n      4\n      4\n      4\n      4\n      4\n    \n    \n      element\n      3.0\n      3.0\n      3.0\n      3.6\n      3.0\n    \n    \n      Tset_H\n      60\n      60\n      75\n      75\n      70\n    \n    \n      Tset_L\n      60\n      60\n      60\n      60\n      60\n    \n    \n      radius\n      0.22\n      0.22\n      0.22\n      0.3\n      0.22\n    \n    \n      height\n      1.1\n      1.1\n      1.1\n      1.4\n      1.1\n    \n    \n      ripple\n      True\n      False\n      False\n      False\n      False\n    \n    \n      start_time\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n      2020-06-01 00:00:00\n    \n    \n      end_time\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n      2020-06-30 23:59:00\n    \n    \n      volume\n      167.258393\n      167.258393\n      167.258393\n      395.840674\n      167.258393\n    \n    \n      peak_demand\n      0.22\n      0.229931\n      0.137083\n      0.105333\n      0.158194\n    \n    \n      local_kwh\n      301.9\n      292.95\n      141.75\n      107.7\n      167.75\n    \n    \n      remote_kwh\n      0.0\n      0.0\n      136.3\n      282.12\n      117.75\n    \n    \n      total_kwh\n      301.9\n      292.95\n      278.05\n      389.82\n      285.5\n    \n    \n      local_cost\n      73.782102\n      75.731868\n      40.302617\n      31.663776\n      47.431951\n    \n    \n      remote_cost\n      0.0\n      0.0\n      19.244775\n      39.456843\n      16.580938\n    \n    \n      total_cost\n      73.782102\n      75.731868\n      59.547392\n      71.120619\n      64.012889\n    \n    \n      t_mean\n      58.963058\n      59.060973\n      70.199214\n      70.702455\n      65.860602\n    \n    \n      loss_of_service\n      1.208333\n      0.87963\n      0.0\n      0.0\n      0.113426\n    \n    \n      peak_reduction\n      0.0\n      4.513889\n      -37.689394\n      -52.121212\n      -28.093434\n    \n    \n      cost_reduction\n      0.0\n      2.642601\n      -19.292904\n      -3.60722\n      -13.240627"
  },
  {
    "objectID": "use.html#assumptions",
    "href": "use.html#assumptions",
    "title": "Simulations",
    "section": "Assumptions",
    "text": "Assumptions\nIn order to have reasonable comparisons over different operating scenarios we will use the draw profile of a specific 4 bedroom unit from a historical hot water usage dataset."
  },
  {
    "objectID": "use.html#base-case",
    "href": "use.html#base-case",
    "title": "Simulations",
    "section": "Base Case",
    "text": "Base Case\nThe base installation is a typical 180L hot water cylinder in a 4 bedroom houshold\n\nstrategies[0] = {'name': 'Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply',\n                'operation': 'continuous',\n                'bedrooms': 4,\n                'element' :3,\n                'Tset_H' : 60,\n                'Tset_L' : 60,\n                'radius' : 0.22,\n                'height' : 1.1,\n                'ripple' : True}\n\n\nstrategy = 0\ntime_period = '2020-06'\nenv = HWC(T_set=strategies[strategy]['Tset_H'], \n            radius=strategies[strategy]['radius'],\n            height=strategies[strategy]['height'],\n            element=strategies[strategy]['bedrooms'],\n            U=.8)\ntemp = []\nflow = load_demand(path = Path('../data/drawprofiles'),\n                    bed=strategies[strategy]['bedrooms'],\n                    unit=3).loc[:,'flow']\nfor row in power.loc[time_period].itertuples(): # go through a set time period\n    action = 0\n    pwr = [1,1]\n    \n    # adjust for temperature\n    env._thermostat()\n    # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n    if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n        if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = ~row.peak\n        elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = 1\n        elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            # action = 1 if row.cost < 0.1 else 0\n            action = 1 if row.costrank_8h < 0.2 else 0\n\n            pwr = [0,1]\n\n\n    if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n        action = 1\n    \n\n    if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n        action = 0\n        pwr[1] = 0 # no power to the element\n\n    env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n    temp.append([strategy,\n                action,\n                row.ripple_control * strategies[strategy]['ripple'] ,\n                *env.thermostat.copy(),\n                *env.temperatures.copy(),\n                env.z,\n                env.volume])\ntmp = pd.DataFrame(temp, \n                        columns=['strategy',\n                                    'action',\n                                    'ripple_control_demand',\n                                    'thermostat_high',\n                                    'thermostat_base',\n                                    'T0',\n                                    'T1',\n                                    'z',\n                                    'volume'])\ndf[strategy] = pd.concat([power.loc[time_period].reset_index(),\n            flow.loc[time_period].reset_index(drop=True),\n            tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\nplot_sim(strategies[strategy], df[strategy].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():"
  },
  {
    "objectID": "use.html#base-case-without-ripple-control",
    "href": "use.html#base-case-without-ripple-control",
    "title": "Simulations",
    "section": "Base Case without Ripple Control",
    "text": "Base Case without Ripple Control\nThe base installation is a typical 180L hot water cylinder in a 4 bedroom houshold however the cylinder is not interupted by ripple control\n\nstrategies[1] = {'name':'Baseline case: current operation with no ripple control',\n            'operation': 'off_peak',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 60,\n            'Tset_L' : 60,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : False}\n\n\ntime_period = '2020-06'\nstrategy = 1\nenv = HWC(T_set=strategies[strategy]['Tset_H'], \n            radius=strategies[strategy]['radius'],\n            height=strategies[strategy]['height'],\n            element=strategies[strategy]['bedrooms'],\n            U=.8)\ntemp = []\nflow = load_demand(path = Path('../data/drawprofiles'),\n                    bed=strategies[strategy]['bedrooms'],\n                    unit=3).loc[:,'flow']\nfor row in power.loc[time_period].itertuples(): # go through a set time period\n    action = 0\n    pwr = [1,1]\n    \n    # adjust for temperature\n    env._thermostat()\n    # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n    if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n        if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = ~row.peak\n        elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = 1\n        elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            # action = 1 if row.cost < 0.1 else 0\n            action = 1 if row.costrank_8h < 0.2 else 0\n\n            pwr = [0,1]\n\n\n    if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n        action = 1\n    \n\n    if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n        action = 0\n        pwr[1] = 0 # no power to the element\n\n    env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n    temp.append([strategy,\n                action,\n                row.ripple_control * strategies[strategy]['ripple'] ,\n                *env.thermostat.copy(),\n                *env.temperatures.copy(),\n                env.z,\n                env.volume])\ntmp = pd.DataFrame(temp, \n                        columns=['strategy',\n                                    'action',\n                                    'ripple_control_demand',\n                                    'thermostat_high',\n                                    'thermostat_base',\n                                    'T0',\n                                    'T1',\n                                    'z',\n                                    'volume'])\ndf[strategy] = pd.concat([power.loc[time_period].reset_index(),\n            flow.loc[time_period].reset_index(drop=True),\n            tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\nplot_sim(strategies[strategy], df[strategy].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():"
  },
  {
    "objectID": "use.html#thermal-boosting-on-base-case-with-ripple-control",
    "href": "use.html#thermal-boosting-on-base-case-with-ripple-control",
    "title": "Simulations",
    "section": "Thermal Boosting on Base Case with Ripple Control",
    "text": "Thermal Boosting on Base Case with Ripple Control\nApply Thermal Boosting Control on the base installation with the cylinder having interupted power supply by ripple control\n\nstrategies[2] = {'name': 'Split Control: remote operation on price signal with ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : True}\n\n\ntime_period = '2020-06'\nstrategy = 2\nenv = HWC(T_set=strategies[strategy]['Tset_H'], \n            radius=strategies[strategy]['radius'],\n            height=strategies[strategy]['height'],\n            element=strategies[strategy]['bedrooms'],\n            U=.8)\ntemp = []\nflow = load_demand(path = Path('../data/drawprofiles'),\n                    bed=strategies[strategy]['bedrooms'],\n                    unit=3).loc[:,'flow']\nfor row in power.loc[time_period].itertuples(): # go through a set time period\n    action = 0\n    pwr = [1,1]\n    \n    # adjust for temperature\n    env._thermostat()\n    # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n    if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n        if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = ~row.peak\n        elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = 1\n        elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            # action = 1 if row.cost < 0.1 else 0\n            action = 1 if row.costrank_8h < 0.2 else 0\n\n            pwr = [0,1]\n\n\n    if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n        action = 1\n    \n\n    if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n        action = 0\n        pwr[1] = 0 # no power to the element\n\n    env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n    temp.append([strategy,\n                action,\n                row.ripple_control * strategies[strategy]['ripple'] ,\n                *env.thermostat.copy(),\n                *env.temperatures.copy(),\n                env.z,\n                env.volume])\ntmp = pd.DataFrame(temp, \n                        columns=['strategy',\n                                    'action',\n                                    'ripple_control_demand',\n                                    'thermostat_high',\n                                    'thermostat_base',\n                                    'T0',\n                                    'T1',\n                                    'z',\n                                    'volume'])\ndf[strategy] = pd.concat([power.loc[time_period].reset_index(),\n            flow.loc[time_period].reset_index(drop=True),\n            tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\nplot_sim(strategies[strategy], df[strategy].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():"
  },
  {
    "objectID": "use.html#thermal-boosting-with-larger-cylinder-and-element",
    "href": "use.html#thermal-boosting-with-larger-cylinder-and-element",
    "title": "Simulations",
    "section": "Thermal Boosting with larger cylinder and element",
    "text": "Thermal Boosting with larger cylinder and element\nApply Thermal Boosting Control on a ~280 L cylinder with a slightly larger element.\n\nstrategies[3] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3.6,\n            'Tset_H' : 75,\n            'Tset_L' : 60,\n            'radius' : 0.25,\n            'height' : 1.4,\n            'ripple' : False}\n\n\ntime_period = '2020-06'\nstrategy = 3\nenv = HWC(T_set=strategies[strategy]['Tset_H'], \n            radius=strategies[strategy]['radius'],\n            height=strategies[strategy]['height'],\n            element=strategies[strategy]['bedrooms'],\n            U=.8)\ntemp = []\nflow = load_demand(path = Path('../data/drawprofiles'),\n                    bed=strategies[strategy]['bedrooms'],\n                    unit=3).loc[:,'flow']\nfor row in power.loc[time_period].itertuples(): # go through a set time period\n    action = 0\n    pwr = [1,1]\n    \n    # adjust for temperature\n    env._thermostat()\n    # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n    if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n        if strategies[strategy]['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = ~row.peak\n        elif strategies[strategy]['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            action = 1\n        elif strategies[strategy]['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n            # action = 1 if row.cost < 0.1 else 0\n            action = 1 if row.costrank_8h < 0.2 else 0\n\n            pwr = [0,1]\n\n\n    if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n        action = 1\n    \n\n    if (strategies[strategy]['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n        action = 0\n        pwr[1] = 0 # no power to the element\n\n    env._update_model(action = action , flow = 2* flow.loc[row.Index]*60)\n    temp.append([strategy,\n                action,\n                row.ripple_control * strategies[strategy]['ripple'] ,\n                *env.thermostat.copy(),\n                *env.temperatures.copy(),\n                env.z,\n                env.volume])\ntmp = pd.DataFrame(temp, \n                        columns=['strategy',\n                                    'action',\n                                    'ripple_control_demand',\n                                    'thermostat_high',\n                                    'thermostat_base',\n                                    'T0',\n                                    'T1',\n                                    'z',\n                                    'volume'])\ndf[strategy] = pd.concat([power.loc[time_period].reset_index(),\n            flow.loc[time_period].reset_index(drop=True),\n            tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\nplot_sim(strategies[strategy], df[strategy].iloc[20000:23500])\n\n/home/cjp/cylinder/cylinder/utils.py:37: FutureWarning: iteritems is deprecated and will be removed in a future version. Use .items instead.\n  for row in ser.iteritems():"
  }
]