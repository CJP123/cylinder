[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cylinder",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cylinder",
    "section": "Install",
    "text": "Install\npip install cylinder\nThis basic model provides the core function for a step change calculation in a mixed hot water cylinder"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "cylinder",
    "section": "How to use",
    "text": "How to use\nLoad some data that can be used to test the model - flow and electricity pricing\n\n# df = (pd.DataFrame(load_demand(path = Path('../data/drawprofiles'),bed=5,unit=4)))\n# df.columns=[\"flow\"]\n# df = df.merge(load_power(path = Path('../data')), how='left', left_index=True, right_index=True)\n# df.head()\n\nCreate a hot water cylinder object and initialise it with the data\n\nhwc = HWC(T_set=70, T_deadband=2, element=3, radius=.2, height=1.5)\n\n\nprint(f'The HWC volume is {int(hwc.volume*1000)} liters')\nprint(f'The HWC surface area is {hwc.surface_area:.2f} m2')\nprint(f'The HWC has a {hwc.element:.2f} kW element')\n\nThe HWC volume is 188 liters\nThe HWC surface area is 2.14 m2\nThe HWC has a 3.00 kW element\n\n\nDefault thermogram\nRun the model for a single day on thermostat and plot the results"
  },
  {
    "objectID": "hwc_2node.html",
    "href": "hwc_2node.html",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "",
    "text": "In order to simulate aleternative control strategies a hot water cylinder environment that approximates the operation under real world conditions is required. There are a large number of models of varying numerical complexity that were reviewed such as:\nModel Predictive Control of Heat Pump Water Heaters for Energy Efficiency\nDynamic modeling of a sensible thermal energy storage tank with an immersed coil heat exchanger under three operation modes\nThese models have been developed to incorporate stratification and internal heat transfer however a simple energy balance model was selected with the addition of an internal conduction variable to decay the stratified layer.\nA minimal simulation of the electricity demand of a domestic hot water cylinder for smart control\n\\(\\Delta \\quad\\) internal heat transfer scaling parameter\n\\(\\dot{m}_{c} \\quad\\) mass flow rate of IHX coil fluid\n\\(\\dot{m}_{c w} \\quad\\) mass flow rate of inlet domestic cold water\n\\(\\dot{m}_{t} \\quad\\) discharge mass flow rate through tank\n\\(\\dot{Q}_{\\text {coil }} \\quad\\) heat transfer rate due to IHX coil\n\\(\\dot{Q}_{j+1}\\) heat transfer rate between nodes \\(j\\) and \\(j+1\\)\n\\(\\dot{Q}_{j-1} \\quad\\) heat transfer rate between nodes \\(j\\) and \\(j-1\\)\n\\(\\dot{Q}_{\\text {wall }}\\) heat transfer rate for losses to surroundings\nA cross-sectional area of node control volume\n\\(A_{w} \\quad\\) wall contact surface area\n\\(c_{v} \\quad\\) specific heat capacity of water\n\\(j \\quad\\) current node in iterative energy equations\n\\(j+1 \\quad\\) represents node below node \\(j\\)\n\\(\\begin{array}{ll}j-1 & \\text { represents node above node } j \\\\ k & \\text { internal node interaction heat transfer coefficient } \\\\ k_{w} & \\text { lumped heat transfer coefficient for losses across walls } \\\\ m & \\text { mass of node } \\\\ s_{1} & \\text { discharge fluid correction factor } \\\\ T & \\text { temperature } \\\\ t & \\text { time } \\\\ T_{c w} & \\text { domestic cold water temperature } \\\\ T_{e n} & \\text { IHX coil fluid inlet temperature } \\\\ T_{e x} & \\text { IHX coil fluid outlet temperature } \\\\ w_{t} & \\text { tank wall thickness } \\\\ z & \\text { vertical height variable with respect to tank bottom }\\end{array}\\)\nsource"
  },
  {
    "objectID": "hwc_2node.html#initialisation",
    "href": "hwc_2node.html#initialisation",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "Initialisation",
    "text": "Initialisation\n\ntemp = []\nfor i in range(10):\n    env = HWC(T_set=75, element=3)\n    temp.append(env.temperatures)\n    assert env.temperatures[0]<= 75.5\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nfig.suptitle('Random initial states of charge for 10 different models')\n\nText(0.5, 0.98, 'Random initial states of charge for 10 different models')\n\n\n\n\n\n\nenv = HWC(T_set=75, element=3, height=1, radius=.5)\n# check that the volume and areas are correct\nassert env.volume == np.pi/4\nassert env.A == np.pi/4"
  },
  {
    "objectID": "hwc_2node.html#passive-losses---no-heating-no-flow",
    "href": "hwc_2node.html#passive-losses---no-heating-no-flow",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "Passive Losses - No Heating + No Flow",
    "text": "Passive Losses - No Heating + No Flow\n\nenv = HWC(T_set=55, element=3, radius=.25, U=.8)\ntemp = []\nminutes = 60*24\nfor minute in range(minutes):\n    env._update_model(action = 0 , flow = 0)\n    temp.append(env.temperatures.copy())\n\n\nCompare to calulation from first principles\n\nmean_cylinder_temperature = (np.vstack(temp)* env.split).sum(axis=1).mean()\npassive_real =   env.U * env.surface_area * (mean_cylinder_temperature - env.T_ambient) # kW/m2K x m2 x K  = KW\npassive_real =   passive_real * 60 * 24 / 1000 # kWh per day\n\nmodel_losses =   env.volume * env.ρ * env.Cv * ((temp[0]* env.split).sum()- (temp[-1]* env.split).sum()) / 1000 \nprint(f'Calculated Passive losses: {passive_real/24:.2f} kWh / hour and a total of {passive_real:.2f} kWh / day')\n\nprint(f'Model Losses:  minutes {model_losses/24:.2f} kWh / hour and a total of {model_losses:.2f} kWh / day')\n\nCalculated Passive losses: 0.06 kWh / hour and a total of 1.50 kWh / day\nModel Losses:  minutes 0.06 kWh / hour and a total of 1.36 kWh / day\n\n\n\nenv = HWC(T_set=75, element=3, radius=.25, U=.8, mixed=True)\ntemp = []\nminutes = 60*24\nfor minute in range(minutes):\n    env._update_model(action = 0 , flow = 0)\n    temp.append(env.temperatures.copy())\n\n\nmean_cylinder_temperature = (np.vstack(temp)* env.split).sum(axis=1).mean()\npassive_real =   env.U * env.surface_area * (mean_cylinder_temperature - env.T_ambient) # kW/m2K x m2 x K  = KW\npassive_real =   passive_real * 60 * 24 / 1000 # kWh per day\n\nmodel_losses =   env.volume * env.ρ * env.Cv * ((temp[0]* env.split).sum()- (temp[-1]* env.split).sum()) / 1000 \nprint(f'Calculated Passive losses: {passive_real/24:.2f} kWh / hour and a total of {passive_real:.2f} kWh / day')\n\nprint(f'Model Losses:  minutes {model_losses/24:.2f} kWh / hour and a total of {model_losses:.2f} kWh / day')\n\nCalculated Passive losses: 0.10 kWh / hour and a total of 2.38 kWh / day\nModel Losses:  minutes 0.00 kWh / hour and a total of 0.00 kWh / day\n\n\n\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nax.plot((np.vstack(temp)*env.split).sum(axis=1), lw=2, ls=':', c='blue')\nfig.suptitle(f'Passive Losses - No Heating + No Flow over {minutes} minutes')\n\nText(0.5, 0.98, 'Passive Losses - No Heating + No Flow over 1440 minutes')\n\n\n\n\n\nThe standing heat loss for a tank should be in the order of 1.7 kWh / day for a tank at 55 degrees. https://sustainableengineering.co.nz/portfolio-item/dhw-tanks-w-k-from-kwh-day/"
  },
  {
    "objectID": "hwc_2node.html#no-heating-flow-rate-of-10-litres-per-minure-for-10-minutes",
    "href": "hwc_2node.html#no-heating-flow-rate-of-10-litres-per-minure-for-10-minutes",
    "title": "Basic A minimal simulation of a domestic hot water cylinder",
    "section": "No Heating + Flow rate of 10 litres per minure for 10 minutes",
    "text": "No Heating + Flow rate of 10 litres per minure for 10 minutes\n\nenv = HWC(T_set=75, element=3, mixed=False)\nflow = 10/60/1000 # 10 litres per minute\ntemp = []\nminutes = 60\nfor minute in range(minutes):\n    action = 0 #np.random.randint(0,2)\n    env._update_model(action = action , flow = flow if minute < 10 else 0)\n    temp.append(env.temperatures.copy())\n\nfig, ax = plt.subplots(figsize=(16,6))\nax.plot(np.vstack(temp))\nax.plot((np.vstack(temp)*env.split).sum(axis=1), lw=2, ls=':', c='blue')\n\nfig.suptitle('No Heating + Flow rate of 10 litres per minure for 10 minutes')\n\nText(0.5, 0.98, 'No Heating + Flow rate of 10 litres per minure for 10 minutes')"
  },
  {
    "objectID": "ripple_control.html",
    "href": "ripple_control.html",
    "title": "New Zealand Ripple Control",
    "section": "",
    "text": "Ripple control statistices to modify the real operation\nRipple control is a technology that is used to manage the supply of electricity in residential hot water cylinders in New Zealand. This technology allows utility companies to remotely control the electricity supply to hot water cylinders, ensuring that electricity is used efficiently and cost-effectively.\nOne of the key benefits of ripple control is that it allows utility companies to manage the demand for electricity during peak periods. By limiting the amount of electricity that is supplied to hot water cylinders during these times, the utility company can help to prevent power outages and ensure that electricity is available to meet the needs of other customers.\nOverall, ripple control is a useful technology that can help to manage the supply of electricity to residential hot water cylinders in New Zealand. By allowing utility companies to control the electricity supply, ripple control can help to prevent power outages, reduce electricity bills, and protect the environment.\nA 2020 research paper by EECA reviews the current state and operation of the ripple control network.\nDetails of ripple control used for load management are detailled on the Orion Network{:target=“_blank”}\n\ndf = pd.read_excel('../data/orion_rc.xlsx', skiprows=11)\ndf = df.dropna(axis=1, how='all').iloc[:,:3]#.set_index('Date')\ndf.columns = ['Date', 'max_off', 'max_ave_off']\ndf = df.set_index('Date')\n# convert h:m:s to seconds\ndf['max_off'] = pd.to_datetime(df['max_off'], format='%H:%M:%S')\ndf['max_ave_off'] = pd.to_datetime(df['max_ave_off'], format='%H:%M:%S')\ndf = df.assign(max_off = lambda x: x['max_off'].dt.hour*60 + x['max_off'].dt.minute + x['max_off'].dt.second/60,\n          max_ave_off = lambda x: x['max_ave_off'].dt.hour*60 + x['max_ave_off'].dt.minute + x['max_ave_off'].dt.second/60,\n          day = lambda x: x.index.dayofweek,\n          month = lambda x: x.index.month,\n          weekday = lambda x: x.index.weekday<5,\n          season = lambda x: x.index.map(get_season))\n\n\ndf\n\n\n\n\n\n  \n    \n      \n      max_off\n      max_ave_off\n      day\n      month\n      weekday\n      season\n    \n    \n      Date\n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2012-05-01\n      74.0\n      17.0\n      1\n      5\n      True\n      Autumn\n    \n    \n      2012-05-02\n      41.0\n      31.0\n      2\n      5\n      True\n      Autumn\n    \n    \n      2012-05-03\n      41.0\n      31.0\n      3\n      5\n      True\n      Autumn\n    \n    \n      2012-05-16\n      70.0\n      54.0\n      2\n      5\n      True\n      Autumn\n    \n    \n      2012-05-17\n      70.0\n      54.0\n      3\n      5\n      True\n      Autumn\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      2022-10-14\n      19.0\n      1.0\n      4\n      10\n      True\n      Spring\n    \n    \n      2022-10-18\n      30.0\n      16.0\n      1\n      10\n      True\n      Spring\n    \n    \n      2022-10-19\n      45.0\n      32.0\n      2\n      10\n      True\n      Spring\n    \n    \n      2022-10-20\n      20.0\n      8.0\n      3\n      10\n      True\n      Spring\n    \n    \n      2022-10-25\n      24.0\n      8.0\n      1\n      10\n      True\n      Spring\n    \n  \n\n1030 rows × 6 columns\n\n\n\nThere is a large variation in frequency based on the season\n\n# do a histogram plot of the max_average_off grouped by season and if the day was a week day or weekend as 4 separate subplots (one for each season)\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\nbins = np.linspace(0, 300, 15)\n\nfor i, season in enumerate(df['season'].unique()):\n    ax = axes[i//2, i%2]\n    t = np.linspace(0, 300, 100)\n    # df[df['season'] == season].groupby('weekday')['max_ave_off'].plot(kind='hist', ax=ax, alpha=0.5, bins=bins, legend=True)\n    print(season,\n            df[(df.season == season)&(df['weekday']==True)].max_ave_off.mean(), \n            df[(df.season == season)&(df['weekday']==True)].max_ave_off.std(),skew(df[(df.season == season)&(df['weekday']==True)].max_ave_off))\n    ax.hist([df[(df.season == season)&(df['weekday']==True)].max_ave_off,\n             df[(df.season == season)&(df['weekday']==False)].max_ave_off],\n             bins=bins, alpha=0.5, label=['weekday','weekend'])\n    ax.set_title(season)\n    ax.set_xlabel('max average off (min)')\n    ax.set_ylabel('frequency')\n    ax.set_ylim(0, 130)\n\n    ax.legend()\nplt.tight_layout()\nfig.suptitle('Frequency plot of Ripple Control \\nin the Orion Network 2012-2022 :max_ave_off minutes by season', fontsize=16, y=1.05)\n\nplt.show()\n\nAutumn 44.92028985507246 52.35728765624028 1.985906057501679\nWinter 70.12273641851107 61.136638232997406 1.205216062727588\nSpring 49.46829268292683 60.15001849552464 1.7514057414449147\nSummer 51.98360655737705 79.70327031735863 1.7129228895001667"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\nget_season\n\n get_season (date)\n\n\nsource\n\n\nseries_timestamps\n\n series_timestamps (ser)\n\n\nsource\n\n\nplot_sim\n\n plot_sim (strategy, df, verbose=True)"
  },
  {
    "objectID": "demand.html",
    "href": "demand.html",
    "title": "Sample Demand Profile",
    "section": "",
    "text": "There are some 1 minute draw profiles for US domestic hot water. The data is from the BEopt. The data requires some cleaning and processing. This data is used to provide input into the model.\n\nsource\n\nload_demand\n\n load_demand (path=None, bed=1, unit=1)\n\n\nflow = load_demand(path = Path('../data/drawprofiles'),\n                      bed=4,\n                      unit=3)\nflow.head()\n\n\n\n\n\n  \n    \n      \n      Showers\n      Sinks\n      CW\n      DW\n      Baths\n      total_lpm\n      total_m3s\n      flow\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-01-01 00:00:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:01:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:02:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:03:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n    \n      2020-01-01 00:04:00\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n      0.0\n    \n  \n\n\n\n\nBad pipe message: %s [b'k\\xce\\xc6\\xcc\\x8f\\xe8\\x91\\xcb\\x97\\xeb\\xde\\xf9K\\xd5\\x1c\\x97*\\x00 \\xa3\\x90\\x10Btx\\xc0\\xd5\\x8c', b'M\\\\\\x9d\\xef39\\xa2\\xfc\\xe1\\x1b\\xa1\\xd6\\xb8\\xb3\\x87nw\\x0c\\xea\\xef\\xcd']\nBad pipe message: %s [b\"\\xb2\\x85}\\xf8x\\x8f\\x8b\\t.\\x93\\xd1\\x7f\\xb2A\\xf2Q\\xe2\\x93\\x00\\x00|\\xc0,\\xc00\\x00\\xa3\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\xaf\\xc0\\xad\\xc0\\xa3\\xc0\\x9f\\xc0]\\xc0a\\xc0W\\xc0S\\xc0+\\xc0/\\x00\\xa2\\x00\\x9e\\xc0\\xae\\xc0\\xac\\xc0\\xa2\\xc0\\x9e\\xc0\\\\\\xc0`\\xc0V\\xc0R\\xc0$\\xc0(\\x00k\\x00j\\xc0#\\xc0'\\x00g\\x00@\\xc0\\n\\xc0\\x14\\x009\\x008\\xc0\\t\\xc0\\x13\\x003\\x002\\x00\\x9d\\xc0\\xa1\\xc0\\x9d\\xc0Q\\x00\\x9c\\xc0\\xa0\\xc0\\x9c\\xc0P\\x00=\\x00<\\x005\\x00/\\x00\\x9a\\x00\\x99\\xc0\\x07\\xc0\\x11\\x00\\x96\\x00\\x05\\x00\\xff\\x01\\x00\\x00j\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\n\\x00\\x0c\\x00\\n\\x00\\x1d\\x00\\x17\\x00\\x1e\\x00\\x19\\x00\\x18\\x00#\\x00\\x00\\x00\\x16\\x00\\x00\\x00\\x17\\x00\\x00\\x00\\r\\x000\\x00.\\x04\\x03\\x05\\x03\\x06\\x03\\x08\\x07\\x08\\x08\\x08\\t\\x08\\n\\x08\\x0b\\x08\\x04\\x08\\x05\\x08\\x06\\x04\\x01\\x05\\x01\\x06\\x01\\x03\", b'\\x03\\x03']\nBad pipe message: %s [b'']\nBad pipe message: %s [b'', b'\\x02']\nBad pipe message: %s [b\"\\x96\\xa1\\x02\\xce\\xf8>J\\x19\\xfaYy\\xe9\\xab\\xd0\\xd0q\\x7f\\x82\\x00\\x00\\xa6\\xc0,\\xc00\\x00\\xa3\\x00\\x9f\\xcc\\xa9\\xcc\\xa8\\xcc\\xaa\\xc0\\xaf\\xc0\\xad\\xc0\\xa3\\xc0\\x9f\\xc0]\\xc0a\\xc0W\\xc0S\\xc0+\\xc0/\\x00\\xa2\\x00\\x9e\\xc0\\xae\\xc0\\xac\\xc0\\xa2\\xc0\\x9e\\xc0\\\\\\xc0`\\xc0V\\xc0R\\xc0$\\xc0(\\x00k\\x00j\\xc0s\\xc0w\\x00\\xc4\\x00\\xc3\\xc0#\\xc0'\\x00g\\x00@\\xc0r\\xc0v\\x00\\xbe\\x00\\xbd\\xc0\\n\\xc0\\x14\\x009\\x008\\x00\\x88\\x00\\x87\\xc0\\t\\xc0\\x13\\x003\\x002\\x00\\x9a\\x00\\x99\\x00E\\x00D\\xc0\\x07\\xc0\\x11\\xc0\\x08\\xc0\\x12\\x00\\x16\\x00\\x13\\x00\\x9d\\xc0\\xa1\\xc0\\x9d\\xc0Q\\x00\\x9c\\xc0\\xa0\\xc0\\x9c\\xc0P\\x00=\\x00\\xc0\\x00<\\x00\\xba\\x005\\x00\\x84\\x00/\\x00\\x96\\x00A\\x00\\x05\\x00\\n\\x00\\xff\\x01\\x00\\x00j\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\", b'\\x01\\x02']\nBad pipe message: %s [b'\\x05\\x02\\x06']\nBad pipe message: %s [b'\\xf7\\xd6Hj7\\xd5\\x16\\xc09u\\xaa;\\xc9\\xab\\x19\\xa5\\x8d$\\x00\\x00>\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\xc0\\x0f\\xc0\\x05\\x005\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00\\x96\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\xff\\x02\\x01\\x00\\x00C\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00\\t127.0.0.1\\x00\\x0b\\x00\\x04\\x03\\x00\\x01\\x02\\x00\\n']\nBad pipe message: %s [b'%q\\xceV$;\\x99\\xaa\\x16\\x13l\\xc2\\x02\\xe2!\\x15/(\\x00\\x00\\xa2\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00:\\x00\\x89\\xc0\\x0f\\xc0\\x05\\x005\\x00\\x84\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x004\\x00\\x9b\\x00F\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x96\\x00A\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\xc0\\x12\\xc0\\x08\\x00\\x16\\x00\\x13\\x00\\x10\\x00\\r\\xc0\\x17\\x00\\x1b\\xc0\\r\\xc0\\x03\\x00\\n\\x00\\x15\\x00\\x12\\x00\\x0f\\x00\\x0c\\x00\\x1a\\x00\\t\\x00\\x14\\x00\\x11\\x00\\x19\\x00']\nBad pipe message: %s [b'\\x06\\x00\\x17\\x00\\x03\\xc0\\x10']\nBad pipe message: %s [b'\\xc2}\\xacs\\xba\\xc3\\t\\x95C\\x14\\xe0*\\x1a~R\\xd2\\x0e\\xa7\\x00\\x00>\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\xc0\\x0f\\xc0\\x05\\x005\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\xc0\\x0e\\xc0\\x04\\x00/\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00\\x96\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\xff\\x02\\x01\\x00\\x00C\\x00\\x00\\x00\\x0e\\x00\\x0c\\x00\\x00']\nBad pipe message: %s [b'A`\\x90\\\\\\x04\\xc8\\xdb\\xdc2\\xa1\\\\']\nBad pipe message: %s [b'e\\\\d\\x83\\xf8\\xdb\\xc4\\x9e\\xffWPI\\xf7v$\\x13R\\xa7\\x00\\x00\\xa2\\xc0\\x14\\xc0\\n\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00:\\x00\\x89\\xc0\\x0f\\xc0\\x05\\x005\\x00\\x84\\xc0\\x13\\xc0\\t\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x004']\nBad pipe message: %s [b'\\x06\\xd7=\\xddS\"q\\rC|\\x99f\\xa7 MFs\\x0f\\x00\\x00\\x86\\xc00\\xc0,\\xc0(\\xc0$\\xc0\\x14\\xc0\\n\\x00\\xa5\\x00\\xa3\\x00\\xa1\\x00\\x9f\\x00k\\x00j\\x00i\\x00h\\x009\\x008\\x007\\x006\\xc02\\xc0.\\xc0*\\xc0&\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00=\\x005\\xc0/\\xc0+\\xc0\\'\\xc0#\\xc0\\x13\\xc0\\t\\x00\\xa4\\x00\\xa2\\x00\\xa0\\x00\\x9e\\x00g\\x00@\\x00?\\x00>\\x003\\x002\\x001\\x000\\xc01\\xc0-\\xc0)\\xc0%\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00<\\x00/\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00\\x96\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\x00\\xff\\x02\\x01\\x00\\x00g\\x00\\x00\\x00\\x0e\\x00']\nBad pipe message: %s [b'\\x00\\t127.0.0.1']\nBad pipe message: %s [b\",\\xccgZ\\x97\\x82\\xbf\\xdbg7\\x84\\x80\\xceV#\\xde\\xca2\\x00\\x00\\xf4\\xc00\\xc0,\\xc0(\\xc0$\\xc0\\x14\\xc0\\n\\x00\\xa5\\x00\\xa3\\x00\\xa1\\x00\\x9f\\x00k\\x00j\\x00i\\x00h\\x009\\x008\\x007\\x006\\x00\\x88\\x00\\x87\\x00\\x86\\x00\\x85\\xc0\\x19\\x00\\xa7\\x00m\\x00:\\x00\\x89\\xc02\\xc0.\\xc0*\\xc0&\\xc0\\x0f\\xc0\\x05\\x00\\x9d\\x00=\\x005\\x00\\x84\\xc0/\\xc0+\\xc0'\\xc0#\\xc0\\x13\\xc0\\t\\x00\\xa4\\x00\\xa2\\x00\\xa0\\x00\\x9e\\x00g\\x00@\\x00?\\x00>\\x003\\x002\\x001\\x000\\x00\\x9a\\x00\\x99\\x00\\x98\\x00\\x97\\x00E\\x00D\\x00C\\x00B\\xc0\\x18\\x00\\xa6\\x00l\\x004\\x00\\x9b\\x00F\\xc01\\xc0-\\xc0)\\xc0%\\xc0\\x0e\\xc0\\x04\\x00\\x9c\\x00<\\x00/\\x00\\x96\\x00A\\x00\\x07\\xc0\\x11\\xc0\\x07\\xc0\\x16\\x00\\x18\\xc0\\x0c\\xc0\\x02\\x00\\x05\\x00\\x04\\xc0\\x12\\xc0\\x08\\x00\\x16\\x00\\x13\\x00\\x10\\x00\", b'\\x17\\x00\\x1b\\xc0\\r\\xc0\\x03\\x00\\n\\x00\\x15\\x00']\nBad pipe message: %s [b'\\x0f\\x00\\x0c\\x00\\x1a\\x00\\t\\x00\\x14\\x00\\x11\\x00\\x19\\x00\\x08\\x00\\x06']\n\n\nLook at one days worth of data for the chosen unit and number of bedrooms.\n\n# fig, ax = plt.subplots(figsize=(12,6))\n# ax.plot(flow['2020-01-01'])\n# ax.set_ylabel('Flow (m3/s)')\n# ax.set_xlabel('Time')\n# ax.set_title('Flow for 2 bed 3 unit')\n\n\nfig, ax = plt.subplots(figsize=(16,6))\n\nax.imshow(flow.groupby([flow.index.hour, flow.index.day_of_week])['flow'].mean().unstack().T*3600, cmap='hot', interpolation='nearest')\nax.set_xlabel('Hour of Day')\nax.set_ylabel('Day of Week')\nfig.suptitle('Average Flow')\n# add colorbar\nfig.colorbar(ax.get_images()[0], ax=ax)\n\n<matplotlib.colorbar.Colorbar at 0x7ff8af555ba0>"
  },
  {
    "objectID": "multi.html",
    "href": "multi.html",
    "title": "Simulations",
    "section": "",
    "text": "Want to look at some parameters around the cylinder profile and control philosophy to see the impact of these on three aspects:"
  },
  {
    "objectID": "multi.html#assumptions",
    "href": "multi.html#assumptions",
    "title": "Simulations",
    "section": "Assumptions",
    "text": "Assumptions\nIn order to have reasonable comparisons over different operating scenarios we will use the draw profile of a specific 4 bedroom unit from a historical hot water usage dataset."
  },
  {
    "objectID": "multi.html#base-case",
    "href": "multi.html#base-case",
    "title": "Simulations",
    "section": "Base Case",
    "text": "Base Case\nThe base installation is a typical 180L hot water cylinder in a 4 bedroom houshold\n\nstrategy = {'name': 'Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply',\n            # 'operation': 'network+',\n            'operation': 'continuous',\n            'element' :3,\n            'Tset_H' : 60.0,\n            'Tset_L' : 60.0,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : True,\n            'high_only': False,\n            'mixed' : False}\n\n\nimport asyncio\nasync def simulation(i, hwc, strategy, df_flow, power, time_period):\n    temp = []\n    # go through each time step and each hwc in the cluster\n    for row in power.loc[time_period].itertuples(): # go through a set time period\n        action = 0\n        element = 0 # heating power\n        # print(strategy)\n        # adjust for temperature\n        hwc._thermostat()\n        # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n        if hwc.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n            if strategy['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = ~row.peak\n                element = 2 if action == 1 else 0\n            elif strategy['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = 1\n                element = 2 if action == 1 else 0\n\n            elif strategy['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.costrank_4h < 0.25 else 0\n                element = 2 if action == 1 else 0\n            elif strategy['operation'] == 'network+': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.pre_peak and row.costrank_4h < 0.5 else 0\n                action = 1 if not row.peak and row.costrank_4h < 0.25 else 0\n                element = 2 if action == 1 else 0\n\n        if hwc.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n            action = 1\n            element = 1\n\n\n        if (strategy['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n            action = 0\n            element = 3\n        # print(action, flow.loc[row.Index]*60)\n        flow = df_flow.loc[row.Index, f'{hwc.unit}_{hwc.bedrooms}']*60\n        hwc._update_model(action = action , flow = flow)\n        temp.append([row.Index,\n                    i, \n                    strategy['operation'],\n                    action,\n                    row.ripple_control * strategy['ripple'] ,\n                    *hwc.thermostat.copy(),\n                    *hwc.temperatures.copy(),\n                    hwc.z,\n                    flow,\n                    hwc.volume,\n                    hwc.bedrooms,\n                    hwc.unit,\n                    element])\n    tmp = pd.DataFrame(temp, \n                      columns=['timestamp',\n                      'id',\n                            'strategy',\n                            'action',\n                            'ripple_control_demand',\n                            'thermostat_high',\n                            'thermostat_base',\n                            'T0',\n                            'T1',\n                            'z',\n                            'flow',\n                            'volume',\n                            'bedrooms',\n                            'unit',\n                            'element_power'])\n    return tmp#.set_index('timestamp')\n\nasync def main(cluster_size, strategy, time_period):\n    df_flow = pd.concat([load_demand(path = Path('../data/drawprofiles'), bed=rooms , unit=unit).loc[:,'flow'].to_frame().rename(columns={'flow':f'{unit}_{rooms}'}) for rooms in range(1,6) for unit in range(10)], axis=1)\n    df_power = load_power(path = Path('../data/'), ripple_control=True) \n    hwcs = [HWC(T_set=strategy['Tset_H'], \n            radius=strategy['radius'],\n            height=strategy['height'],\n            element=strategy['element'],\n            high_only=strategy['high_only'],\n            U=.8,\n            K=.05,\n            noisey=False,\n            bedrooms = random.choice(list(range(1,5))),\n            unit=random.choice(list(range(1,10)))) for i in range(cluster_size)]\n    res = await asyncio.gather(*[simulation(i, hwc, strategy, df_flow, df_power, time_period) for i, hwc in enumerate(hwcs)]) \n    return  pd.concat(res).set_index('timestamp').merge(df_power.loc[time_period], left_index=True, right_index=True, how='left')\n\n\nres = await main(cluster_size=21, strategy = strategy , time_period='2020-06')\nres.head()\n\n\n\n\n\n  \n    \n      \n      id\n      strategy\n      action\n      ripple_control_demand\n      thermostat_high\n      thermostat_base\n      T0\n      T1\n      z\n      flow\n      ...\n      hour\n      day\n      peak\n      tou\n      cost\n      pre_peak\n      costrank_4h\n      costrank_6h\n      costrank_8h\n      costrank_12h\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-06-01\n      0\n      continuous\n      1\n      0\n      1\n      1\n      58.987682\n      56.881135\n      0.7\n      0.0\n      ...\n      0\n      0\n      False\n      0.020004\n      0.032318\n      False\n      0.004166\n      0.002777\n      0.002083\n      0.001389\n    \n    \n      2020-06-01\n      1\n      continuous\n      1\n      0\n      1\n      1\n      58.987682\n      56.881135\n      0.7\n      0.0\n      ...\n      0\n      0\n      False\n      0.020004\n      0.032318\n      False\n      0.004166\n      0.002777\n      0.002083\n      0.001389\n    \n    \n      2020-06-01\n      2\n      continuous\n      1\n      0\n      1\n      1\n      58.987682\n      56.881135\n      0.7\n      0.0\n      ...\n      0\n      0\n      False\n      0.020004\n      0.032318\n      False\n      0.004166\n      0.002777\n      0.002083\n      0.001389\n    \n    \n      2020-06-01\n      3\n      continuous\n      1\n      0\n      1\n      1\n      58.987682\n      56.881135\n      0.7\n      0.0\n      ...\n      0\n      0\n      False\n      0.020004\n      0.032318\n      False\n      0.004166\n      0.002777\n      0.002083\n      0.001389\n    \n    \n      2020-06-01\n      4\n      continuous\n      1\n      0\n      1\n      1\n      58.987682\n      56.881135\n      0.7\n      0.0\n      ...\n      0\n      0\n      False\n      0.020004\n      0.032318\n      False\n      0.004166\n      0.002777\n      0.002083\n      0.001389\n    \n  \n\n5 rows × 30 columns\n\n\n\n\ndf =res['2020-06-08':'2020-06-08']\ndf = df.assign(T_mean = lambda df: df.T0*df.z + df.T1*(1-df.z),\n            energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55)\n    )\n\n\ndf.groupby('timestamp').energy.sum().plot()\n\n<AxesSubplot: xlabel='timestamp'>\n\n\n\n\n\n\nboost_color = 'tab:orange'\nnetwork_color = 'tab:green'\nnetwork_rc = 'tab:brown'\nnetwork_color = 'tab:green'\nfig, ax = plt.subplots(nrows=5,figsize=(18,6), sharey=\"row\", gridspec_kw=dict(height_ratios=[.2,.2,.2,3,3], hspace=0))\n\nim2 = ax[0].imshow(df.groupby('timestamp').energy.sum().values[np.newaxis,:], cmap=\"viridis\", aspect=\"auto\")\nax[0].set_ylabel('Energy', rotation=0, fontsize=8)\n\nax[1].imshow(df.groupby('timestamp').flow.sum().values[np.newaxis,:], cmap=\"Reds\", aspect=\"auto\")\nax[1].set_ylabel('Flow', rotation=0, fontsize=8)\n\nim = ax[2].imshow(df.groupby('timestamp').cost.mean().values[np.newaxis,:], cmap=\"jet\", aspect=\"auto\")\nax[2].set_ylabel('Cost', rotation=0, fontsize=8)\n\nfor i in range(3):\n    ax[i].yaxis.set_label_coords(-0.03,.2)\n    ax[i].set_yticks([])\n    ax[i].set_xticks([])\n\n# add title\ntitle = f'Simulation:'+ strategy['name'] + '\\n' +\\\n        'mode : ' + strategy['operation'] + ' | ' +\\\n        'ripple : ' + str(strategy['ripple'])\n\n\ni=3\n# ax[i].hist(df[df.element_power>0].groupby('timestamp').element_power.sum(), label=f'T{j}')\nax[i].bar(df[df.element_power>0].groupby('timestamp').element_power.sum().index, 3*df[df.element_power>0].groupby('timestamp').element_power.sum().values,width=0.01 )\nax[i].plot( 3*df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red')\n# ax[i].plot( df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red', ls=':')\n\n\nax[i].set_ylabel('kW', rotation=90)\nax[i].set_ylim(0,1.1*(3*max(df[df.element_power>0].groupby('timestamp').element_power.sum())))\nax[i].margins(x=0, y=0)\n\ni=4\nfor j in df.id.unique():\n    ax[i].plot(df[df.id==j].T_mean, label=f'T{j}', alpha=1 if j % 12 == 0 else .1)\n# ax[i].plot(df.groupby('id').T_mean)\nax[i].set_ylim(50,83)\n\nax[i].set_ylabel('°C', rotation=90)\nax[i].margins(x=0, y=0)\nax[i].axhline(y=55, color='grey', linestyle='--', alpha = .5)\n\n# for k in series_timestamps((df.thermostat_base == 1)&(df.ripple_control)&(strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_rc, alpha=0.5, hatch ='\\\\', ec='black') # wants power but ripple control is on\n# for k in series_timestamps((df.element_power == 3)&(df.ripple_control)&(~strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color='blue', alpha=0.5) # wants power but ripple control is on\n\n# # show the actual power usage\n# for k in series_timestamps((df.element_power == 1)): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_color, alpha=0.5)\n# for k in series_timestamps((df.element_power == 2)): ax[i].axvspan(k[0], k[1],  0.08, .13,color=boost_color, alpha=0.5)\n\n\n# operation_legend = [Patch(facecolor=network_rc, hatch ='\\\\', ec='black', alpha=0.5 , label='Demand / No Power'),\n#                     Patch(facecolor='blue', alpha=0.5 ,  label='Operation during Ripple Control'),\n#                     Patch(facecolor=boost_color, alpha=0.5 ,  label='Boost Operation'),\n#                     Patch(facecolor=network_color, alpha=0.5 ,   label='Base Operation')]\n\n# show the network status\n\n# for k in series_timestamps((df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_rc, alpha=0.5) # wants power but ripple control is on\n# for k in series_timestamps((df.peak)): ax[i].axvspan(k[0], k[1], 0, .05, fc='none',hatch ='xx', ec='grey') # wants power but ripple control is on\n# for k in series_timestamps((~df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_color, alpha=0.5) # wants power but ripple control is on\nnetwork_legend = [Patch(facecolor='red', alpha=0.5 , label='Ripple Control'),\n                    Patch(facecolor=network_color, alpha=0.5 ,  label='Normal Operation'),\n                    Patch(facecolor='none', hatch='xx', ec='grey', label='Peak Demand')]\n\n\n# legend1 = plt.legend(handles = network_legend,loc='upper center',title=\"Electricity Network\", bbox_to_anchor=(0.2, -0.12), fancybox=True, shadow=False, ncol=3)\n# legend2 = plt.legend(handles = operation_legend,loc='upper center',title=\"Operation\", bbox_to_anchor=(0.7,-.12), fancybox=True, shadow=False, ncol=4)\n# ax[i].add_artist(legend1)\n# ax[i].add_artist(legend2)\n\n# add a colorbar for the price to the right of the plot\nfig.subplots_adjust(right=0.9)\ncbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])\nfig.colorbar(im, cax=cbar_ax)\ncbar_ax.set_ylabel('Price [$/kWh]', rotation=90, labelpad=5, fontsize=6)\ncbar_ax.yaxis.set_label_position('right')\ncbar_ax.yaxis.set_ticks_position('left')\ncbar_ax.yaxis.set_tick_params(pad=5)\n# cbar_ax.set_ylim(0, 0.2)\ncbar1_ax = fig.add_axes([0.97, 0.1, 0.02, 0.8])\nfig.colorbar(im2, cax=cbar1_ax)\ncbar1_ax.set_ylabel('kWh', rotation=90, labelpad=5, fontsize=6)\ncbar1_ax.yaxis.set_label_position('right')\ncbar1_ax.yaxis.set_ticks_position('left')\ncbar1_ax.yaxis.set_tick_params(pad=5)\n\ndate_form = DateFormatter('%d %b\\n %H:%M')\nax[-1].xaxis.set_major_formatter(date_form)\ncbar_ax.yaxis.set_tick_params(labelsize=6)\ncbar1_ax.yaxis.set_tick_params(labelsize=6)\nax[i].annotate('network', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 10), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\nax[i].annotate('operation', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 28), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\n# add some whitespace to the bottom of the plot\n# add a line at the end of each day\n# if verbose:\n#     complete_days = df.groupby('date').size().reset_index()\n#     complete_days = pd.to_datetime(complete_days[complete_days[0]==1440].date.tolist())\n#     # print(complete_days)\n#     for n,k in enumerate(complete_days): \n#         e1 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)].element_power.count()\n#         e2 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].element_power.count()\n#         e1p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)&(df.peak)].element_power.count()\n#         e2p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)&(df.peak)].element_power.count()\n#         e3 = 0\n#         en_max = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.max()\n#         en_min = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.min()\n#         en_range = abs(en_max-en_min)\n\n#         # print(en_range,e2,e3)\n#         c = (df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].element_power * \\\n#             df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].cost).sum() /60*strategy['element']\n#         kwh = (e1+e2)/60*strategy['element']\n#         avecost = c/kwh\n#         base = k + pd.Timedelta(f'1d')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m'), base, 0.92, .95, color=boost_color, alpha=0.5, ec='black')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m') - pd.Timedelta(f'{e1}m'), base-pd.Timedelta(f'{e2}m'), 0.92, .95, color=network_color, alpha=0.5, ec='black')\n#         ax[i].annotate(f'{kwh:.1f} kWh', xy=(base- pd.Timedelta(f'{e1+e2+e3}m'), 80), xycoords='data',  xytext=(-3, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n#         ax[i].annotate(f'${avecost:.2f} /kWh', xy=(base, 80), xycoords='data',  xytext=(3, 0), textcoords='offset points', ha=\"left\", va=\"center\", fontsize=8)\n        \n#         ax[i].annotate(f'{en_range:.2f} kWh', xy=(base, 82), xycoords='data',  xytext=(0, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n\n#     for k in df.index.floor('D').unique()[1:]: ax[i].axvline(k, color='grey', alpha = .1)\n\n\n\nfig.subplots_adjust(bottom=0.25)\nfig.suptitle(title)\n    # return\n\nText(0.5, 0.98, 'Simulation:Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply\\nmode : continuous | ripple : True')\n\n\n\n\n\n\nboost_color = 'tab:orange'\nnetwork_color = 'tab:green'\nnetwork_rc = 'tab:brown'\nnetwork_color = 'tab:green'\nfig, ax = plt.subplots(nrows=5,figsize=(18,6), sharey=\"row\", gridspec_kw=dict(height_ratios=[.2,.2,.2,3,3], hspace=0))\n\nim2 = ax[0].imshow(df.groupby('timestamp').energy.sum().values[np.newaxis,:], cmap=\"viridis\", aspect=\"auto\")\nax[0].set_ylabel('Energy', rotation=0, fontsize=8)\n\nax[1].imshow(df.groupby('timestamp').flow.sum().values[np.newaxis,:], cmap=\"Reds\", aspect=\"auto\")\nax[1].set_ylabel('Flow', rotation=0, fontsize=8)\n\nim = ax[2].imshow(df.groupby('timestamp').cost.mean().values[np.newaxis,:], cmap=\"jet\", aspect=\"auto\")\nax[2].set_ylabel('Cost', rotation=0, fontsize=8)\n\nfor i in range(3):\n    ax[i].yaxis.set_label_coords(-0.03,.2)\n    ax[i].set_yticks([])\n    ax[i].set_xticks([])\n\n# add title\ntitle = f'Simulation:'+ strategy['name'] + '\\n' +\\\n        'mode : ' + strategy['operation'] + ' | ' +\\\n        'ripple : ' + str(strategy['ripple'])\n\n\ni=3\n# ax[i].hist(df[df.element_power>0].groupby('timestamp').element_power.sum(), label=f'T{j}')\nax[i].bar(df[df.element_power>0].groupby('timestamp').element_power.sum().index, 3*df[df.element_power>0].groupby('timestamp').element_power.sum().values,width=0.01 )\nax[i].plot( 3*df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red')\n# ax[i].plot( df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red', ls=':')\n\n\nax[i].set_ylabel('kW', rotation=90)\nax[i].set_ylim(0,1.1*(3*max(df[df.element_power>0].groupby('timestamp').element_power.sum())))\nax[i].margins(x=0, y=0)\n\ni=4\nfor j in df.id.unique():\n    ax[i].plot(df[df.id==j].T_mean, label=f'T{j}', alpha=1 if j % 12 == 0 else .1)\n# ax[i].plot(df.groupby('id').T_mean)\nax[i].set_ylim(50,83)\n\nax[i].set_ylabel('°C', rotation=90)\nax[i].margins(x=0, y=0)\nax[i].axhline(y=55, color='grey', linestyle='--', alpha = .5)\n\n# for k in series_timestamps((df.thermostat_base == 1)&(df.ripple_control)&(strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_rc, alpha=0.5, hatch ='\\\\', ec='black') # wants power but ripple control is on\n# for k in series_timestamps((df.element_power == 3)&(df.ripple_control)&(~strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color='blue', alpha=0.5) # wants power but ripple control is on\n\n# # show the actual power usage\n# for k in series_timestamps((df.element_power == 1)): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_color, alpha=0.5)\n# for k in series_timestamps((df.element_power == 2)): ax[i].axvspan(k[0], k[1],  0.08, .13,color=boost_color, alpha=0.5)\n\n\n# operation_legend = [Patch(facecolor=network_rc, hatch ='\\\\', ec='black', alpha=0.5 , label='Demand / No Power'),\n#                     Patch(facecolor='blue', alpha=0.5 ,  label='Operation during Ripple Control'),\n#                     Patch(facecolor=boost_color, alpha=0.5 ,  label='Boost Operation'),\n#                     Patch(facecolor=network_color, alpha=0.5 ,   label='Base Operation')]\n\n# show the network status\n\n# for k in series_timestamps((df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_rc, alpha=0.5) # wants power but ripple control is on\n# for k in series_timestamps((df.peak)): ax[i].axvspan(k[0], k[1], 0, .05, fc='none',hatch ='xx', ec='grey') # wants power but ripple control is on\n# for k in series_timestamps((~df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_color, alpha=0.5) # wants power but ripple control is on\nnetwork_legend = [Patch(facecolor='red', alpha=0.5 , label='Ripple Control'),\n                    Patch(facecolor=network_color, alpha=0.5 ,  label='Normal Operation'),\n                    Patch(facecolor='none', hatch='xx', ec='grey', label='Peak Demand')]\n\n\n# legend1 = plt.legend(handles = network_legend,loc='upper center',title=\"Electricity Network\", bbox_to_anchor=(0.2, -0.12), fancybox=True, shadow=False, ncol=3)\n# legend2 = plt.legend(handles = operation_legend,loc='upper center',title=\"Operation\", bbox_to_anchor=(0.7,-.12), fancybox=True, shadow=False, ncol=4)\n# ax[i].add_artist(legend1)\n# ax[i].add_artist(legend2)\n\n# add a colorbar for the price to the right of the plot\nfig.subplots_adjust(right=0.9)\ncbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])\nfig.colorbar(im, cax=cbar_ax)\ncbar_ax.set_ylabel('Price [$/kWh]', rotation=90, labelpad=5, fontsize=6)\ncbar_ax.yaxis.set_label_position('right')\ncbar_ax.yaxis.set_ticks_position('left')\ncbar_ax.yaxis.set_tick_params(pad=5)\n# cbar_ax.set_ylim(0, 0.2)\ncbar1_ax = fig.add_axes([0.97, 0.1, 0.02, 0.8])\nfig.colorbar(im2, cax=cbar1_ax)\ncbar1_ax.set_ylabel('kWh', rotation=90, labelpad=5, fontsize=6)\ncbar1_ax.yaxis.set_label_position('right')\ncbar1_ax.yaxis.set_ticks_position('left')\ncbar1_ax.yaxis.set_tick_params(pad=5)\n\ndate_form = DateFormatter('%d %b\\n %H:%M')\nax[-1].xaxis.set_major_formatter(date_form)\ncbar_ax.yaxis.set_tick_params(labelsize=6)\ncbar1_ax.yaxis.set_tick_params(labelsize=6)\nax[i].annotate('network', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 10), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\nax[i].annotate('operation', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 28), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\n# add some whitespace to the bottom of the plot\n# add a line at the end of each day\n# if verbose:\n#     complete_days = df.groupby('date').size().reset_index()\n#     complete_days = pd.to_datetime(complete_days[complete_days[0]==1440].date.tolist())\n#     # print(complete_days)\n#     for n,k in enumerate(complete_days): \n#         e1 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)].element_power.count()\n#         e2 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].element_power.count()\n#         e1p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)&(df.peak)].element_power.count()\n#         e2p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)&(df.peak)].element_power.count()\n#         e3 = 0\n#         en_max = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.max()\n#         en_min = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.min()\n#         en_range = abs(en_max-en_min)\n\n#         # print(en_range,e2,e3)\n#         c = (df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].element_power * \\\n#             df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].cost).sum() /60*strategy['element']\n#         kwh = (e1+e2)/60*strategy['element']\n#         avecost = c/kwh\n#         base = k + pd.Timedelta(f'1d')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m'), base, 0.92, .95, color=boost_color, alpha=0.5, ec='black')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m') - pd.Timedelta(f'{e1}m'), base-pd.Timedelta(f'{e2}m'), 0.92, .95, color=network_color, alpha=0.5, ec='black')\n#         ax[i].annotate(f'{kwh:.1f} kWh', xy=(base- pd.Timedelta(f'{e1+e2+e3}m'), 80), xycoords='data',  xytext=(-3, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n#         ax[i].annotate(f'${avecost:.2f} /kWh', xy=(base, 80), xycoords='data',  xytext=(3, 0), textcoords='offset points', ha=\"left\", va=\"center\", fontsize=8)\n        \n#         ax[i].annotate(f'{en_range:.2f} kWh', xy=(base, 82), xycoords='data',  xytext=(0, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n\n#     for k in df.index.floor('D').unique()[1:]: ax[i].axvline(k, color='grey', alpha = .1)\n\n\n\nfig.subplots_adjust(bottom=0.25)\nfig.suptitle(title)\n    # return\n\nText(0.5, 0.98, 'Simulation:Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply\\nmode : network+ | ripple : True')\n\n\n\n\n\n\n# count to 100 and make a variable true for every 10th\n# if the variable is true, print the number\n\n# for i in range(100):\n#     if i % 10 == 0:\n\n\n# def plot_multi(strategy, df, verbose=True):\nboost_color = 'tab:orange'\nnetwork_color = 'tab:green'\nnetwork_rc = 'tab:brown'\nnetwork_color = 'tab:green'\nfig, ax = plt.subplots(nrows=5,figsize=(18,6), sharey=\"row\", gridspec_kw=dict(height_ratios=[.2,.2,.2,3,3], hspace=0))\n\n# im2 = ax[0].imshow(df.energy.values[np.newaxis,:], cmap=\"viridis\", aspect=\"auto\", vmin=0, vmax=18)\nax[0].set_ylabel('Energy', rotation=0, fontsize=8)\n\nax[1].imshow(df.groupby('timestamp').flow.sum().values[np.newaxis,:], cmap=\"Reds\", aspect=\"auto\")\nax[1].set_ylabel('Flow', rotation=0, fontsize=8)\n\nim = ax[2].imshow(df.groupby('timestamp').cost.mean().values[np.newaxis,:], cmap=\"jet\", aspect=\"auto\")\nax[2].set_ylabel('Cost', rotation=0, fontsize=8)\n\nfor i in range(3):\n    ax[i].yaxis.set_label_coords(-0.03,.2)\n    ax[i].set_yticks([])\n    ax[i].set_xticks([])\n\n# add title\ntitle = f'Simulation:'+ strategy['name'] + '\\n' +\\\n        'mode : ' + strategy['operation'] + ' | ' +\\\n        'bedrooms : ' + str(strategy['bedrooms']) + '\\n' +\\\n        'element : ' + str(strategy['element']) + 'kW | ' +\\\n        'ripple : ' + str(strategy['ripple'])\n\n\ni=3\n# ax[i].hist(df[df.element_power>0].groupby('timestamp').element_power.sum(), label=f'T{j}')\nax[i].bar(df[df.element_power>0].groupby('timestamp').element_power.sum().index, 3*df[df.element_power>0].groupby('timestamp').element_power.sum().values,width=0.01 )\nax[i].plot( 3*df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red')\n# ax[i].plot( df[df.element_power>0].groupby('timestamp').element_power.sum(), color = 'red', ls=':')\n\n\nax[i].set_ylabel('kW', rotation=90)\nax[i].set_ylim(0,1.1*(3*max(df[df.element_power>0].groupby('timestamp').element_power.sum())))\nax[i].margins(x=0, y=0)\n\ni=4\nfor j in range(2):\n    ax[i].plot(df[f'T{j}'], label=f'T{j}')\nax[i].set_ylim(50,83)\n\nax[i].set_ylabel('°C', rotation=90)\nax[i].margins(x=0, y=0)\nax[i].axhline(y=55, color='grey', linestyle='--', alpha = .5)\n\n# for k in series_timestamps((df.thermostat_base == 1)&(df.ripple_control)&(strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_rc, alpha=0.5, hatch ='\\\\', ec='black') # wants power but ripple control is on\n# for k in series_timestamps((df.element_power == 3)&(df.ripple_control)&(~strategy['ripple'])): ax[i].axvspan(k[0], k[1], 0.08, .13, color='blue', alpha=0.5) # wants power but ripple control is on\n\n# # show the actual power usage\n# for k in series_timestamps((df.element_power == 1)): ax[i].axvspan(k[0], k[1], 0.08, .13, color=network_color, alpha=0.5)\n# for k in series_timestamps((df.element_power == 2)): ax[i].axvspan(k[0], k[1],  0.08, .13,color=boost_color, alpha=0.5)\n\n\n# operation_legend = [Patch(facecolor=network_rc, hatch ='\\\\', ec='black', alpha=0.5 , label='Demand / No Power'),\n#                     Patch(facecolor='blue', alpha=0.5 ,  label='Operation during Ripple Control'),\n#                     Patch(facecolor=boost_color, alpha=0.5 ,  label='Boost Operation'),\n#                     Patch(facecolor=network_color, alpha=0.5 ,   label='Base Operation')]\n\nax[i].axhline(y=55, color='k', linestyle='--', alpha = .5)\n# show the network status\n\n# for k in series_timestamps((df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_rc, alpha=0.5) # wants power but ripple control is on\n# for k in series_timestamps((df.peak)): ax[i].axvspan(k[0], k[1], 0, .05, fc='none',hatch ='xx', ec='grey') # wants power but ripple control is on\n# for k in series_timestamps((~df.ripple_control)): ax[i].axvspan(k[0], k[1], 0, .05, color=network_color, alpha=0.5) # wants power but ripple control is on\nnetwork_legend = [Patch(facecolor='red', alpha=0.5 , label='Ripple Control'),\n                    Patch(facecolor=network_color, alpha=0.5 ,  label='Normal Operation'),\n                    Patch(facecolor='none', hatch='xx', ec='grey', label='Peak Demand')]\n\n\n# legend1 = plt.legend(handles = network_legend,loc='upper center',title=\"Electricity Network\", bbox_to_anchor=(0.2, -0.12), fancybox=True, shadow=False, ncol=3)\n# legend2 = plt.legend(handles = operation_legend,loc='upper center',title=\"Operation\", bbox_to_anchor=(0.7,-.12), fancybox=True, shadow=False, ncol=4)\n# ax[i].add_artist(legend1)\n# ax[i].add_artist(legend2)\n\n# add a colorbar for the price to the right of the plot\nfig.subplots_adjust(right=0.9)\ncbar_ax = fig.add_axes([0.92, 0.1, 0.02, 0.8])\nfig.colorbar(im, cax=cbar_ax)\ncbar_ax.set_ylabel('Price [$/kWh]', rotation=90, labelpad=5, fontsize=6)\ncbar_ax.yaxis.set_label_position('right')\ncbar_ax.yaxis.set_ticks_position('left')\ncbar_ax.yaxis.set_tick_params(pad=5)\n# cbar_ax.set_ylim(0, 0.2)\ncbar1_ax = fig.add_axes([0.97, 0.1, 0.02, 0.8])\n# fig.colorbar(im2, cax=cbar1_ax)\ncbar1_ax.set_ylabel('kWh', rotation=90, labelpad=5, fontsize=6)\ncbar1_ax.yaxis.set_label_position('right')\ncbar1_ax.yaxis.set_ticks_position('left')\ncbar1_ax.yaxis.set_tick_params(pad=5)\n\ndate_form = DateFormatter('%d %b\\n %H:%M')\nax[-1].xaxis.set_major_formatter(date_form)\ncbar_ax.yaxis.set_tick_params(labelsize=6)\ncbar1_ax.yaxis.set_tick_params(labelsize=6)\nax[i].annotate('network', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 10), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\nax[i].annotate('operation', xy=(0, 0), xycoords='axes fraction',  xytext=(5, 28), textcoords='offset points', ha=\"left\", va=\"top\", fontsize=8)\n# add some whitespace to the bottom of the plot\n# add a line at the end of each day\n# if verbose:\n#     complete_days = df.groupby('date').size().reset_index()\n#     complete_days = pd.to_datetime(complete_days[complete_days[0]==1440].date.tolist())\n#     # print(complete_days)\n#     for n,k in enumerate(complete_days): \n#         e1 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)].element_power.count()\n#         e2 = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].element_power.count()\n#         e1p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==1)&(df.peak)].element_power.count()\n#         e2p = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)&(df.peak)].element_power.count()\n#         e3 = 0\n#         en_max = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.max()\n#         en_min = df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)].energy.min()\n#         en_range = abs(en_max-en_min)\n\n#         # print(en_range,e2,e3)\n#         c = (df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].element_power * \\\n#             df.loc[k.date().strftime('%Y-%m-%d')].loc[(df.element_power==2)|(df.element_power==1)].cost).sum() /60*strategy['element']\n#         kwh = (e1+e2)/60*strategy['element']\n#         avecost = c/kwh\n#         base = k + pd.Timedelta(f'1d')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m'), base, 0.92, .95, color=boost_color, alpha=0.5, ec='black')\n#         ax[i].axvspan(base-pd.Timedelta(f'{e2}m') - pd.Timedelta(f'{e1}m'), base-pd.Timedelta(f'{e2}m'), 0.92, .95, color=network_color, alpha=0.5, ec='black')\n#         ax[i].annotate(f'{kwh:.1f} kWh', xy=(base- pd.Timedelta(f'{e1+e2+e3}m'), 80), xycoords='data',  xytext=(-3, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n#         ax[i].annotate(f'${avecost:.2f} /kWh', xy=(base, 80), xycoords='data',  xytext=(3, 0), textcoords='offset points', ha=\"left\", va=\"center\", fontsize=8)\n        \n#         ax[i].annotate(f'{en_range:.2f} kWh', xy=(base, 82), xycoords='data',  xytext=(0, 0), textcoords='offset points', ha=\"right\", va=\"center\", fontsize=8)\n\n#     for k in df.index.floor('D').unique()[1:]: ax[i].axvline(k, color='grey', alpha = .1)\n\n\n\nfig.subplots_adjust(bottom=0.25)\nfig.suptitle(title)\n    # return\n\nText(0.5, 0.98, 'Simulation:Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply\\nmode : network+ | bedrooms : 4\\nelement : 3kW | ripple : True')\n\n\n\n\n\n\nplt.bar(df[df.element_power>0].groupby('timestamp').element_power.sum().index, df[df.element_power>0].groupby('timestamp').element_power.sum().values,width=0.01 )\n\n<BarContainer object of 285 artists>\n\n\n\n\n\n\ndf.id.unique()\n\narray([0, 1, 2])"
  },
  {
    "objectID": "db.html",
    "href": "db.html",
    "title": "cylinder",
    "section": "",
    "text": "# make and store data in a database using sqlite3\n# https://docs.python.org/3/library/sqlite3.html\n\nimport sqlite3\nimport pandas as pd\n\n\n\n# create a database\nconn = sqlite3.connect('data.db')\nc = conn.cursor()\n\n\n# create a table in the database with the following columns: date, gxip, s2_emissions\nc.execute('''CREATE TABLE IF NOT EXISTS data\n                (date text, gxip real, s2_emissions real)''')\n\n<sqlite3.Cursor at 0x7f4df79d0a40>\n\n\n\n# read the data from the database into a pandas dataframe\ndf = pd.read_sql_query(\"SELECT * FROM data\", conn)\ndf\n\n\n\n\n\n  \n    \n      \n      date\n      gxip\n      s2_emissions"
  },
  {
    "objectID": "use.html",
    "href": "use.html",
    "title": "Simulations",
    "section": "",
    "text": "Want to look at some parameters around the cylinder profile and control philosophy to see the impact of these on three aspects:"
  },
  {
    "objectID": "use.html#assumptions",
    "href": "use.html#assumptions",
    "title": "Simulations",
    "section": "Assumptions",
    "text": "Assumptions\nIn order to have reasonable comparisons over different operating scenarios we will use the draw profile of a specific 4 bedroom unit from a historical hot water usage dataset.\n\npower\n\n\n\n\n\n  \n    \n      \n      price\n      ripple_control\n      price_kw\n      date\n      week\n      season\n      hour\n      day\n      peak\n      tou\n      cost\n      n_cost\n      sr_cost\n      lr_cost\n      pre_peak\n      costrank_4h\n      costrank_6h\n      costrank_8h\n      costrank_12h\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-01-01 11:59:00\n      21.858\n      False\n      0.021858\n      2020-01-01\n      1\n      Summer\n      11\n      2\n      0\n      0.02\n      0.041858\n      -0.08142\n      0.163122\n      0.151413\n      False\n      0.204167\n      0.302778\n      0.477083\n      0.651389\n    \n    \n      2020-01-01 12:00:00\n      21.860\n      False\n      0.021860\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.041860\n      -0.08140\n      0.162465\n      0.151270\n      False\n      0.231250\n      0.318056\n      0.488542\n      0.659028\n    \n    \n      2020-01-01 12:01:00\n      22.230\n      False\n      0.022230\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042230\n      -0.07770\n      0.160373\n      0.149827\n      False\n      0.258333\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:02:00\n      22.600\n      False\n      0.022600\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042600\n      -0.07400\n      0.158294\n      0.148426\n      False\n      0.262500\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:03:00\n      22.970\n      False\n      0.022970\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042970\n      -0.07030\n      0.156227\n      0.147066\n      False\n      0.266667\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      2020-12-31 21:51:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.181917\n      0.194701\n      False\n      0.027083\n      0.018056\n      0.013542\n      0.009028\n    \n    \n      2020-12-31 21:52:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182253\n      0.194996\n      False\n      0.029167\n      0.019444\n      0.014583\n      0.009722\n    \n    \n      2020-12-31 21:53:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182548\n      0.195280\n      False\n      0.031250\n      0.020833\n      0.015625\n      0.010417\n    \n    \n      2020-12-31 21:54:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.182802\n      0.195554\n      False\n      0.033333\n      0.022222\n      0.016667\n      0.011111\n    \n    \n      2020-12-31 21:55:00\n      77.170\n      False\n      0.077170\n      2020-12-31\n      53\n      Summer\n      21\n      3\n      0\n      0.02\n      0.097170\n      0.47170\n      0.183015\n      0.195817\n      False\n      0.035417\n      0.023611\n      0.017708\n      0.011806\n    \n  \n\n526197 rows × 19 columns"
  },
  {
    "objectID": "use.html#base-case",
    "href": "use.html#base-case",
    "title": "Simulations",
    "section": "Base Case",
    "text": "Base Case\nThe base installation is a typical 180L hot water cylinder in a 4 bedroom houshold\n\nstrategies[0] = {'name': 'Baseline: ~180L 3kW cylinder operating at 60 degrees C under thermotstat control with ripple control power supply',\n                'operation': 'continuous',\n                'unit': 4,\n                'bedrooms': 4,\n                'element' :3,\n                'Tset_H' : 60.0,\n                'Tset_L' : 60.0,\n                'radius' : 0.22,\n                'height' : 1.1,\n                'ripple' : True,\n                'high_only': False,\n                'mixed' : False}\n\n\ndef run_simulation(strategy, power, time_period):\n    env = HWC(T_set=strategy['Tset_H'], \n            radius=strategy['radius'],\n            height=strategy['height'],\n            element=strategy['bedrooms'],\n            mixed=strategy['mixed'],\n            high_only=strategy['high_only'],\n            T_cold=15,\n            T_inlet=15,\n            U=.8,\n            K=.05,\n            noisey=False,\n            bedrooms=strategy['bedrooms'],\n            unit=strategy['unit'],)\n    temp = []\n    # flow = load_demand(path = Path('../data/drawprofiles'),\n    #                 bed=strategy['bedrooms'],\n    #                 unit=0).loc[:,'flow']\n    df_flow = pd.concat([(load_demand(path = Path('../data/drawprofiles'), bed=rooms , unit=unit).loc[:,'flow']\n                      .to_frame()\n                      .rename(columns={'flow':f'{unit}_{rooms}'})) for rooms in range(1,6) for unit in range(10)], axis=1)\n    for row in power.loc[time_period].itertuples(): # go through a set time period\n        action = 0\n        element = 0 # heating power\n        # print(strategy)\n        # adjust for temperature\n        env._thermostat()\n        # establish if there is power going to the element based on the thermostat state and the strategy in relation to ripple control\n        if env.thermostat[0] == 1: # if the thermostat high temperature sensor is on then need to look to the control strategy\n            if strategy['operation'] == 'off_peak': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = ~row.peak\n                element = 2 if action == 1 else 0\n            elif strategy['operation'] == 'continuous': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                action = 1\n                element = 2 if action == 1 else 0\n\n            elif strategy['operation'] == 'price': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.costrank_4h < 0.25 else 0\n                element = 2 if action == 1 else 0\n            elif strategy['operation'] == 'network+': # if the strategy is to use the thermostat high temperature sensor then the element is on\n                # action = 1 if row.cost < 0.1 else 0\n                action = 1 if row.pre_peak and row.costrank_4h < 0.5 else 0\n                action = 1 if not row.peak and row.costrank_4h < 0.15 else 0\n                element = 2 if action == 1 else 0\n\n        if env.thermostat[1] == 1: # if the thermostat base temperature sensor is on then the element is on\n            action = 1\n            element = 1\n\n\n        if (strategy['ripple']) & (row.ripple_control): # if ripple control is on then override the thermostat state\n            action = 0\n            element = 3\n        # print(action, flow.loc[row.Index]*60)\n        flow = df_flow.loc[row.Index, f'{env.unit}_{env.bedrooms}']*60\n        env._update_model(action = action , flow = flow)\n        temp.append([action,\n                    row.ripple_control * strategy['ripple'] ,\n                    *env.thermostat.copy(),\n                    *env.temperatures.copy(),\n                    env.z,\n                    flow,\n                    env.volume,\n                    element])\n    tmp = pd.DataFrame(temp, \n                      columns=['action',\n                            'ripple_control_demand',\n                            'thermostat_high',\n                            'thermostat_base',\n                            'T0',\n                            'T1',\n                            'z',\n                            'flow',\n                            'volume',\n                            'element_power'])\n    return pd.concat([power.loc[time_period].reset_index(),\n            tmp.assign(energy = lambda df: df.volume.mean()*4.2*((df.T0*df.z + df.T1*(1-df.z))-55))],axis=1).set_index('timestamp')\n\n\ndf[0] = run_simulation(strategies[0], power, time_period='2020-06')\n\n\ndf[0].strategy\n\ntimestamp\n2020-06-01 00:00:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-01 00:01:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-01 00:02:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-01 00:03:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-01 00:04:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n                                             ...                        \n2020-06-30 23:55:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-30 23:56:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-30 23:57:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-30 23:58:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\n2020-06-30 23:59:00    {'name': 'Baseline: ~180L 3kW cylinder operati...\nName: strategy, Length: 43200, dtype: object\n\n\n\nplot_sim(strategies[0], df[0].iloc[:3800],verbose=True)\n\n\n\n\n\nplot_sim(strategies[0], df[0].iloc[:3800])"
  },
  {
    "objectID": "use.html#base-case-without-ripple-control",
    "href": "use.html#base-case-without-ripple-control",
    "title": "Simulations",
    "section": "Base Case without Ripple Control",
    "text": "Base Case without Ripple Control\nThe base installation is a typical 180L hot water cylinder in a 4 bedroom houshold however the cylinder is not interupted by ripple control\n\nstrategies[1] = {'name':'Baseline case: current operation with no ripple control',\n            'operation': 'off_peak',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 60.,\n            'Tset_L' : 60.,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : False,\n            'high_only': False,\n            'mixed' : False,\n            }\n\n\nplot_sim(strategies[1], df[1].iloc[:3800], verbose=True)"
  },
  {
    "objectID": "use.html#thermal-boosting-on-base-case-with-no-ripple-control",
    "href": "use.html#thermal-boosting-on-base-case-with-no-ripple-control",
    "title": "Simulations",
    "section": "Thermal Boosting on Base Case with no Ripple Control",
    "text": "Thermal Boosting on Base Case with no Ripple Control\nApply Thermal Boosting Control on the base installation with the cylinder withou ripple control\n\nstrategies[2] = {'name': 'Split Control: remote operation on price signal with ripple control',\n            'operation': 'price',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 75.,\n            'Tset_L' : 60.,\n            'radius' : 0.22,\n            'height' : 1.1,\n            'ripple' : False,\n            'mixed' : True,\n            'high_only' : False,\n            }\n\n\nplot_sim(strategies[2], df[2].iloc[:3800], verbose=True)\n\n\n\n\n\nplot_sim(strategies[2], df[2].iloc[:3800], verbose=True)"
  },
  {
    "objectID": "use.html#thermal-boosting-with-larger-cylinder-and-element",
    "href": "use.html#thermal-boosting-with-larger-cylinder-and-element",
    "title": "Simulations",
    "section": "Thermal Boosting with larger cylinder and element",
    "text": "Thermal Boosting with larger cylinder and element\nApply Thermal Boosting Control on a ~280 L cylinder with a slightly larger element.\n\nstrategies[3] = {'name': 'Split Control: remote operation on price signal with no ripple control',\n            'operation': 'network+',\n            'bedrooms': 4,\n            'element' :3,\n            'Tset_H' : 75.,\n            'Tset_L' : 60.,\n            'radius' : 0.25,\n            'height' : 1.1,\n            'high_only': True,\n            'ripple' : False,\n            'mixed' : False,}\n\n\nplot_sim(strategies[3], df[3].iloc[:3800], verbose=True)\n\n\n\n\n\n# get grouped aggregate data\ndf[2].assign(prop = lambda df: df.energy/df.energy.max()).groupby(['date']).agg({'energy':{'min','max'},'prop':{'min','max'}}).plot()\n# df[2].groupby(['date']).agg({'energy':{'min','max'}}),\n\n<AxesSubplot: xlabel='date'>"
  },
  {
    "objectID": "power.html",
    "href": "power.html",
    "title": "Electricity Wholesale Price Data",
    "section": "",
    "text": "Electricity pricing data is sourced from the Electricity Authority.\nThe data provides a real signal that can be used to interact with the hot water cylinder simulation.\nThe wholesale data has local time of use charges added based on Vector 2022 Local Network Pricing. This is the public facing signal for network constraint but represents a step-change in local per kWh charges at fixed times.\nThere are generated ‘ripple control’ periods generated to simulate the potential for cylinder power to be ‘turned off’ remotely by the local network.\nThe development of real time emissions data at a regional level is part of another project and in the absense of this the price is treated as a proxy for the carbon content of the generated electricity. This is not a perfect proxy, but it is a reasonable one.\n\nsource\n\nload_power\n\n load_power (path=None, ripple_control=False)\n\nThis function loads up historical wholesate electrical pricing within the NZ electricity market. Some time of use charges are applied to the data. The data is then resampled to 1 minute intervals and interpolated to fill in missing values. The data is then normalized and a rolling average is applied to provide a short and long term average of the cost. The data is then ranked to provide a percentile ranking of the cost. The data is then split into seasons and a random selection of dates are selected to apply a ripple control. A dataframe is returned for the power prices with some additional features.\nA sample of the power pricing from mid-February\n\ndf = load_power(path = Path('../data/'), ripple_control=True)\ndf.head()\n\n\n\n\n\n  \n    \n      \n      price\n      ripple_control\n      price_kw\n      date\n      week\n      season\n      hour\n      day\n      peak\n      tou\n      cost\n      n_cost\n      sr_cost\n      lr_cost\n      pre_peak\n      costrank_4h\n      costrank_6h\n      costrank_8h\n      costrank_12h\n    \n    \n      timestamp\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      2020-01-01 11:59:00\n      21.858\n      False\n      0.021858\n      2020-01-01\n      1\n      Summer\n      11\n      2\n      0\n      0.02\n      0.041858\n      -0.08142\n      0.163122\n      0.151413\n      False\n      0.204167\n      0.302778\n      0.477083\n      0.651389\n    \n    \n      2020-01-01 12:00:00\n      21.860\n      False\n      0.021860\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.041860\n      -0.08140\n      0.162465\n      0.151270\n      False\n      0.231250\n      0.318056\n      0.488542\n      0.659028\n    \n    \n      2020-01-01 12:01:00\n      22.230\n      False\n      0.022230\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042230\n      -0.07770\n      0.160373\n      0.149827\n      False\n      0.258333\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:02:00\n      22.600\n      False\n      0.022600\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042600\n      -0.07400\n      0.158294\n      0.148426\n      False\n      0.262500\n      0.333333\n      0.500000\n      0.666667\n    \n    \n      2020-01-01 12:03:00\n      22.970\n      False\n      0.022970\n      2020-01-01\n      1\n      Summer\n      12\n      2\n      0\n      0.02\n      0.042970\n      -0.07030\n      0.156227\n      0.147066\n      False\n      0.266667\n      0.333333\n      0.500000\n      0.666667\n    \n  \n\n\n\n\n\n# plot the power prices over a week in winter\nfig, ax = plt.subplots(figsize=(15,5))\nax.plot(df['2020-06-13':'2020-06-20'].cost, label='Power Prices')\nax2 = ax.twinx()\nax2.plot(df['2020-06-13':'2020-06-20'].ripple_control, color = 'orange',label='Ripple Control')\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d %b %H:%M'))\n# show both legends on the same plot\nlines, labels = ax.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax.legend(lines + lines2, labels + labels2, loc=0)\n# ax.legend()\nax.set_title('Power Prices and Simulated Ripple Control')\nplt.show()\n\n\n\n\nOne simple potential methodology for pricing is to rank the current price of electricity relative to the upcoming x hours. Two of the foreward price ranked calculations are shown on the following graph. With the historical dataset it is possible to calculate this exactly however the forward pricing is a fundamental part of the electricity market so it is possible to make this calculation with high certainty using available data. The time of use rate portion of the cost also has a significant impact that generally pushes the price at peak times into a higher rank independent of the wholesale pricing.\nThe NZ Market Prices provides an example of the forward variability as an example.\n\n# plot the power prices over a week in winter\nfig, ax = plt.subplots(figsize=(15,5))\nax.plot(df.loc['2020-06-13'].cost, label='Power Prices')\nax2 = ax.twinx()\n# ax2.plot(df['2020-06-13'].ripple_control, color = 'orange',label='Ripple Control')\nax2.plot(df.loc['2020-06-13'].costrank_6h, label='% of 6 hour rolling cost', ls='--')\nax2.plot(df.loc['2020-06-13'].costrank_12h, label='% of 12 hour rolling cost', ls='--')\n\nax.xaxis.set_major_formatter(mdates.DateFormatter('%d %b %H:%M'))\n# show both legends on the same plot\nlines, labels = ax.get_legend_handles_labels()\nlines2, labels2 = ax2.get_legend_handles_labels()\nax.legend(lines + lines2, labels + labels2, loc=0)\n# ax.legend()\nax.set_title('Power Prices and rank of rolling cost over 6 and 12 hours')\nplt.show()"
  }
]