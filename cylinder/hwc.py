# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_hwc.ipynb.

# %% auto 0
__all__ = ['HWC']

# %% ../nbs/20_hwc.ipynb 3
from fastcore.utils import *
import pandas as pd
import matplotlib.pyplot as plt
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import scipy.linalg
import scipy.signal as signal


# %% ../nbs/20_hwc.ipynb 8
class HWC():
  """
  Model of a Hot Water Cylinder using a nodal approach.
  """
  def __init__(self,
              element = 3,        # kW
              T_set = 75,         # °C
              T_deadband = 2,     # °C
              radius =.25,        # m
              height = 1.1,       # m
              nodes = 7,
              delta = 100000,
              U = 0.8):
    super(HWC, self).__init__()
    self.U = U/60     # 0.5-0.8 kJ/min m2K typical heat transfer losses to ambient  [0.5 kJ/min m2K Jack Paper] kW/m2K
    self.nodes = nodes
    self.Cp = 4.184 #kJ/kgK
    self.ρ = 1000 #kg/m3
    self.delta = delta
    self.T_ambient = 15 #  Air temperature that the cylinder located in °C
    self.T_cold = 15 # Make up water temperature °C
    self.T_demand = 45 #T_demand - temperature of the end use (shower)  °C
    self.T_deadband = T_deadband #T_deadband  - thermostat deadband °C
    self.T_set = T_set #T_set - thermostat set point °C
    self.element = element # kW = kJ/s
    self.radius = radius
    self.height = height
    # self.alpha = 0.01
    self.T_set_bu = 60
    temperature = self.T_set + np.random.uniform(-5, 0)
    self.temperatures = np.linspace(temperature+np.random.uniform(.5, 0),temperature-np.random.uniform(5, 0),self.nodes)
    self.thermostat = np.array([0,0]) # bulk / nodal high / nodal low
    self.element_node = int(self.nodes*.75)
    # self._thermostat()
    
  @property
  def surface_area(self): return 2* np.pi * self.radius * self.height + 2 * np.pi * self.radius**2 # m2

  @property
  def volume(self): return np.pi * self.radius ** 2 * self.height  # m3

  @property
  def heat_capacity(self): return self.Cp * self.ρ * self.volume # kJ/K

  @property
  def x_section_area(self): return np.pi * self.radius**2 # m2 

  @property
  def cylinder_wall_area(self): return 2* np.pi * self.radius * self.height  # m2 

  @property
  def Δz(self): return self.height / self.nodes # m

  @property
  def uas(self): 
    uas = np.ones((self.nodes)) * self.U * self.cylinder_wall_area / self.nodes # unit  heat transfer coefficient kW/K
    uas[0]  += self.U * self.x_section_area               # Add end heat losses
    uas[-1] += self.U * self.x_section_area               # Add end heat losses
    return uas #  

  @property
  def nj(self): return self.heat_capacity / self.nodes

  @property
  def K(self): return 1                                        

  @property
  def s1(self): return .92                                        

  @property
  def Δ(self):  return self.delta                                        # internal heat transfer scaling parameter 


# %% ../nbs/20_hwc.ipynb 12
@patch
def _update_model(self:HWC, action = None, flow = None, timestep_sec=60):
    micro_step = timestep_sec/10 # 6 seconds
    for i in range(10):
        A,B = self.make_matrix(action = action, flow = flow)
        timesteps = np.linspace(0,micro_step,10)
    # print('-----')    
        print(B)
    # print(timesteps)

        sys = signal.StateSpace(A* micro_step * self.heat_capacity / self.nodes, B* micro_step *self.heat_capacity / self.nodes, np.ones((1,self.nodes)) , np.zeros((1,3)))

        u = np.ones([len(timesteps),3])*np.array([action, flow>0, self.T_ambient])
    # print(u)
        _,_,temperature = signal.lsim(sys, u, timesteps, self.temperatures)
        self.temperatures = temperature[-1]
    return 


# %% ../nbs/20_hwc.ipynb 13
@patch
def make_matrix(self:HWC,action = None, flow = None):
    k = self._temperature_inversion()  # check for temperature inversion and update the conductivity to correct
    A = np.identity(self.nodes)
    # dz = np.linspace(env.height,0,env.nodes)
    
    # Build alpha in the matrix
    for j in range(1,self.nodes-1):
        A[j][j] =  -(k[j-1] * self.x_section_area / self.Δz +  
                      k[j+1] * self.x_section_area / self.Δz +  
                      self.uas[j]) 
    A[0][0] =      -(k[1] * self.x_section_area / self.Δz  + 
                      self.uas[0])
    A[-1][-1] =    -(k[-2] * self.x_section_area / self.Δz + 
                      self.uas[-1])
    # Build beta in the matrix
    for j in range(self.nodes-1):
        A[j][j+1] = k[j+1] * self.x_section_area / self.Δz # β beta is from node below

    for j in range(1,self.nodes):
        A[j][j-1] = k[j-1] * self.x_section_area / self.Δz  # γ gamma is from node below
        
    # print(A)
    '''
    create continuous state space matrix Bc
    Bc = [top_element, bottom_element, flow, wall_losses]


    '''
    B= np.zeros((self.nodes,3))

    B[self.element_node ,  0]       = 0.8 *self.element      # inject 80% of lower element power at no/self.njde ~75% from the top
    B[self.element_node+1, 0]       = 0.2 *self.element         # inject remainder in the node below
    
    for j in range(0,self.nodes-1):
        B[j,1] =  flow*self.s1 * self.Cp  * (self.temperatures[j+1] - self.temperatures[j]) # add water flow to the node
    B[-1,1] =   flow*self.s1 * self.Cp * min(0,(self.T_cold - self.temperatures[-1])) # add cold water flow to the last node

    B[:,2] = self.uas   # Energy flow as heat loss to the room from the cylinder wall
    return A, B

# %% ../nbs/20_hwc.ipynb 15
@patch
def _temperature_inversion(self:HWC):
    k = np.ones(self.nodes)*self.K
    for j in range(len(k)-1):
        if (j != 0) & (self.temperatures[j] > self.temperatures[j-1]): k[j-1] = max(0.01,k[j-1] * self.Δ *abs(self.temperatures[j] - self.temperatures[j-1]))  # if node j is hotter than node above
        if (j != self.nodes-1) & (self.temperatures[j] < self.temperatures[j+1]): k[j+1] = max(0.01,k[j+1] * self.Δ * abs(self.temperatures[j] - self.temperatures[j+1])) # if node j is colder than node below
    # if self.temperatures[-1] > self.temperatures[-2]: k[-2] = k[-2] * self.Δ *abs(self.temperatures[-1] - self.temperatures[-2])  # if bottom node is hotter than node above
    # print(k,self.temperatures)
    return k
