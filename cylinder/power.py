# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_power.ipynb.

# %% auto 0
__all__ = ['load_power']

# %% ../nbs/10_power.ipynb 3
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from pathlib import Path

# %% ../nbs/10_power.ipynb 5
def load_power(path = None):
    "Return power price"
    return (pd.read_csv(path/'powerprices.csv')
            .assign(timestamp = lambda df_: pd.to_datetime(df_.dt))
            .set_index('timestamp')
            .drop(columns = ['dt', 'poc', 'date', 'time', 'island','del', 'del2', 'del3'])
            .sort_index()
            .resample('60S')
            .mean()
            .interpolate()
            .assign(price = lambda df_: df_.price.interpolate(method='linear'),
                    price_kw = lambda df_: df_.price/1000,
                    date = lambda df_: df_.index.date,
                    week = lambda df_: df_.index.isocalendar().week,
                    hour = lambda df_: df_.index.hour,
                    day = lambda df_: df_.index.dayofweek,
                    peak = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), 1, 0), # 1 if peak hour, 0 otherwise
                    tou = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), .12, .02), # add tou price
                    cost = lambda df_: df_.price_kw+df_.tou, # add tou price
                    n_cost = lambda df_ :-0.5+ (df_.cost - 0) / (.1 - 0), # normalize cost - bit hacky
    	            sr_cost = lambda df_ :df_.cost.rolling(60).mean().shift(-60)/df_.cost/6, # provide a 1 hour (short run) rolling average of cost
    	            lr_cost = lambda df_ :df_.cost.rolling(120).mean().shift(-120)/df_.cost/6, # provide a 2 hour (longer run) rolling average of cost
            )
            .dropna()
            .drop(columns=['trade'])
            )
