# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/60_power.ipynb.

# %% auto 0
__all__ = ['load_power']

# %% ../nbs/60_power.ipynb 3
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from .utils import *

from pathlib import Path
from datetime import datetime, timedelta
from scipy.stats import skew, skewnorm
import random

# %% ../nbs/60_power.ipynb 5
def load_power(path = None, ripple_control = False):
    '''
    This function loads up historical wholesate electrical pricing within the NZ electricity market. 
    Some time of use charges are applied to the data.
    The data is then resampled to 1 minute intervals and interpolated to fill in missing values.
    The data is then normalized and a rolling average is applied to provide a short and long term average of the cost.
    The data is then ranked to provide a percentile ranking of the cost.
    The data is then split into seasons and a random selection of dates are selected to apply a ripple control.
    A dataframe is returned for the power prices with some additional features.
    '''
    seasons = ['Summer', 'Autumn', 'Winter', 'Spring']
    season_skew = [1.7, 1.9, 1.2, 1.8]
    season_freq = [0.1, 0.3, 0.6, 0.2]
    season_mean = [52, 45, 70, 50]
    season_std = [80, 52, 61, 60]
    df = (pd.read_csv(path/'powerprices.csv')
            .assign(timestamp = lambda df_: pd.to_datetime(df_.dt))
            .set_index('timestamp')
            .drop(columns = ['dt', 'poc', 'date', 'time', 'island','del', 'del2', 'del3'])
            .sort_index()
            .resample('60S')
            .mean()
            .interpolate()
            .assign(price = lambda df_: df_.price.interpolate(method='linear').astype('float16'),
                ripple_control = False,
                price_kw = lambda df_: (df_.price/1000).astype('float16'),
                date = lambda df_: df_.index.date,
                week = lambda df_: df_.index.isocalendar().week,
                season = lambda df_: df_.index.map(get_season),
                hour = lambda df_: df_.index.hour.astype('int16'),
                day = lambda df_: df_.index.dayofweek.astype('int8'),
                peak = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), True, False), # 1 if peak hour, 0 otherwise
                tou = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), .12, .02).astype('float16'), # add tou price
                cost = lambda df_: (df_.price_kw+df_.tou).astype('float16'), # add tou price
                # n_cost = lambda df_ :-0.5+ (df_.cost - 0) / (.1 - 0), # normalize cost - bit hacky
                # sr_cost = lambda df_ :df_.cost.rolling(60).mean().shift(-60)/df_.cost/6, # provide a 1 hour (short run) rolling average of cost
                # lr_cost = lambda df_ :df_.cost.rolling(120).mean().shift(-120)/df_.cost/6, # provide a 2 hour (longer run) rolling average of cost
                pre_peak = lambda df_: np.where((df_.hour.isin([6,16])& (~df_.day <5)), True, False), # add tou price
                costrank_4h = lambda df_:df_.cost.rolling(window=4*60).rank(pct=True).astype('float16'),
                costrank_6h = lambda df_:df_.cost.rolling(window=6*60).rank(pct=True).astype('float16'),
                costrank_8h = lambda df_:df_.cost.rolling(window=8*60).rank(pct=True).astype('float16'),
                costrank_12h = lambda df_:df_.cost.rolling(window=12*60).rank(pct=True).astype('float16'),
            )
            .dropna()
            .drop(columns=['trade'])
            )

    i=0
    if ripple_control:
        for season, freq in zip(seasons, season_freq):
            ripple_dates = df[(df.season == season)&(df.day < 5)&(df.cost >.4)].drop_duplicates('date').sample(frac=freq).index.normalize()
            for date_ in ripple_dates:
                    start_time = date_ + timedelta(hours=random.choice([6,7,8,17,18]), minutes=random.randint(0,59))
                    # print(date_.date(),start_time)
                    end_time = start_time + timedelta(minutes=skewnorm.rvs(2, loc=season_mean[i], scale=season_std[i], size=1)[0].clip(min=15))
                    df['ripple_control'] = np.where((df.index >= start_time) & (df.index <= end_time), True, df['ripple_control'])    
            i+=1
    return df
