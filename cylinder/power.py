# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_power.ipynb.

# %% auto 0
__all__ = ['get_season', 'load_power']

# %% ../nbs/10_power.ipynb 3
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from pathlib import Path
from datetime import datetime, timedelta
from scipy.stats import skew, skewnorm
import random

# %% ../nbs/10_power.ipynb 5
def get_season(date):
  month = date.month
  if month  >= 3 and month <= 5:
    return "Autumn"
  elif month >= 6 and month <= 8:
    return "Winter"
  elif month >= 9 and month <= 11:
    return "Spring"
  else:
    return "Summer"

# %% ../nbs/10_power.ipynb 6
def load_power(path = None, ripple_control = False):
    "Return power price"
    seasons = ['Summer', 'Autumn', 'Winter', 'Spring']

    season_skew = [1.7, 1.9, 1.2, 1.8]
    season_freq = [0.1, 0.3, 0.6, 0.2]
    season_mean = [52, 45, 70, 50]
    season_std = [80, 52, 61, 60]
    df = (pd.read_csv(path/'powerprices.csv')
            .assign(timestamp = lambda df_: pd.to_datetime(df_.dt))
            .set_index('timestamp')
            .drop(columns = ['dt', 'poc', 'date', 'time', 'island','del', 'del2', 'del3'])
            .sort_index()
            .resample('60S')
            .mean()
            .interpolate()
            .assign(price = lambda df_: df_.price.interpolate(method='linear'),
                ripple_control = False,
                price_kw = lambda df_: df_.price/1000,
                date = lambda df_: df_.index.date,
                week = lambda df_: df_.index.isocalendar().week,
                season = lambda df_: df_.index.map(get_season),
                hour = lambda df_: df_.index.hour,
                day = lambda df_: df_.index.dayofweek,
                peak = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), 1, 0), # 1 if peak hour, 0 otherwise
                tou = lambda df_: np.where((df_.hour.isin([7,8,9,10,17,18,19,20])& (~df_.day <5)), .12, .02), # add tou price
                cost = lambda df_: df_.price_kw+df_.tou, # add tou price
                n_cost = lambda df_ :-0.5+ (df_.cost - 0) / (.1 - 0), # normalize cost - bit hacky
                sr_cost = lambda df_ :df_.cost.rolling(60).mean().shift(-60)/df_.cost/6, # provide a 1 hour (short run) rolling average of cost
                lr_cost = lambda df_ :df_.cost.rolling(120).mean().shift(-120)/df_.cost/6, # provide a 2 hour (longer run) rolling average of cost
            )
            .dropna()
            .drop(columns=['trade'])
            )

    i=0
    if ripple_control:
        for season, freq in zip(seasons, season_freq):
            ripple_dates = df[(df.season == season)&(df.day < 5)&(df.cost >.4)].drop_duplicates('date').sample(frac=freq).index.normalize()
            for date_ in ripple_dates:
                    start_time = date_ + timedelta(hours=random.choice([6,7,8,17,18]), minutes=random.randint(0,59))
                    # print(date_.date(),start_time)
                    end_time = start_time + timedelta(minutes=skewnorm.rvs(2, loc=season_mean[i], scale=season_std[i], size=1)[0].clip(min=15))
                    df['ripple_control'] = np.where((df.index >= start_time) & (df.index <= end_time), True, df['ripple_control'])    
            i+=1
    return df
