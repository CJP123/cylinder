# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_hwc_2node.ipynb.

# %% auto 0
__all__ = ['HWC']

# %% ../nbs/20_hwc_2node.ipynb 3
from fastcore.utils import *
import pandas as pd
import matplotlib.pyplot as plt
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import scipy.linalg
import scipy.signal as signal


# %% ../nbs/20_hwc_2node.ipynb 8
class HWC():
  """
  Model of a Hot Water Cylinder using a nodal approach.
  """
  def __init__(self,
              element = 3,        # kW
              T_set = 75,         # °C
              T_deadband = 2,     # °C
              radius =.25,        # m
              height = 1.1,       # m
              U = 0.8,
              noisey = True):
    super(HWC, self).__init__()
    self.U = U/60     # 0.5-0.8 kJ/min m2K typical heat transfer losses to ambient  [0.5 kJ/min m2K Jack Paper] kW/m2K
    self.split = np.array([.7,.3])
    self.Cv = 4.184 #kJ/kgK
    self.ρ = 1000 #kg/m3
    self.T_ambient = 15 #  Air temperature that the cylinder located in °C
    self.T_cold = 15 # Make up water temperature °C
    self.T_demand = 45 #T_demand - temperature of the end use (shower)  °C
    self.T_deadband = T_deadband #T_deadband  - thermostat deadband °C
    self.T_set = T_set #T_set - thermostat set point °C
    self.element = element # kW = kJ/s
    self.radius = radius
    self.height = height
    self.T_set_bu = 60
    temperature = self.T_set + np.random.uniform(-5, 0)
    if noisey:
      self.temperatures = np.array([temperature,temperature+ np.random.uniform(-5, 0)])
    else:
      self.temperatures = np.array([self.T_set -1, self.T_set-4])
    self.thermostat = np.array([0,0]) # bulk / nodal high / nodal low
    # self._thermostat()
    
  @property
  def surface_area(self): return 2* np.pi * self.radius * self.height + 2 * np.pi * self.radius**2 # m2

  @property
  def volume(self): return np.pi * self.radius ** 2 * self.height  # m3

  @property
  def m(self): return self.split * self.volume * self.ρ # kg

  @property
  def h(self): return self.split * self.height # kg

  @property
  def heat_capacity(self): return self.Cv * self.ρ * self.volume # kJ/K

  @property
  def A(self): return np.pi * self.radius**2 # m2 

  @property
  def cylinder_wall_area(self): return 2* np.pi * self.radius * self.height  # m2 

  @property
  def uas(self): 
    uas = self.split * self.U * self.cylinder_wall_area   # unit  heat transfer coefficient kW/K
    uas[0]  += self.U * self.A               # Add end heat losses
    uas[1] += self.U * self.A               # Add end heat losses
    return uas #  

  @property
  def k(self): return 50                                        

  @property
  def s1(self): return 1                                        


# %% ../nbs/20_hwc_2node.ipynb 12
@patch
def make_matrix(self:HWC, action = None, flow = None):
    A = np.zeros((2,2))
    action_k = self.k if action == 1 else self.k/10
    A[0][0] = -(1 / (self.m[0] * self.Cv)) * \
               (action_k * self.A / self.h[0] + \
                self.uas[0] + \
                flow * self.ρ * self.Cv)
    A[0][1] =  (1 / (self.m[0] * self.Cv)) * \
               (action_k * self.A / self.h[0]  + \
                flow * self.ρ * self.Cv )
    A[1][0] =  (1 / (self.m[1] * self.Cv)) * \
               (action_k * self.A / self.h[1]   )
    A[1][1] = -(1 / (self.m[1] * self.Cv)) * \
               (action_k * self.A / self.h[1]  +\
                self.uas[1] + \
                flow * self.ρ * self.Cv)

    B= np.zeros((2,3))
    B[0 , 0]   = 0     
    B[1 , 0]   = self.element / self.m[1]         # add element to the bottom node
    B[0 , 1]   = 1/self.m[0] * (self.temperatures[1]-self.temperatures[0])    
    B[1 , 1]   = 1/self.m[1] * (self.T_cold-self.temperatures[1])          # add element to the bottom node
    B[: , 2]   = self.uas/ (self.m * self.Cv)   # Energy flow as heat loss to the room from the cylinder wall


    # for j in range(0,self.nodes-1):
    #     B[j,1] =  flow*self.s1 * self.Cv  * (self.temperatures[j+1] - self.temperatures[j]) # add water flow to the node
    # B[-1,1] =   flow*self.s1 * self.Cv * min(0,(self.T_cold - self.temperatures[-1])) # add cold water flow to the last node

    return A, B

# %% ../nbs/20_hwc_2node.ipynb 13
@patch
def _update_model(self:HWC, action = None, flow = None, timestep_sec=60):
    A,B = self.make_matrix(action = action, flow = flow)
    steps = 5
    timesteps = np.linspace(0,timestep_sec,steps)
    tempered_flow = (flow*(self.T_demand-self.T_cold) /(self.temperatures[0]-self.T_cold).clip(min=0))
    u = np.ones([len(timesteps),3])*np.array([action, tempered_flow*self.ρ, self.T_ambient])
    sys = signal.StateSpace(A *steps/timestep_sec, B *steps/timestep_sec, np.ones((1,2)) , np.zeros((1,3)))
    _,_,temperature =signal.lsim(sys, u, timesteps, self.temperatures)
    self.temperatures = temperature[-1]
    return 

