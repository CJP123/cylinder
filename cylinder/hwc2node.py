# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/20_hwc_2node.ipynb.

# %% auto 0
__all__ = ['HWC']

# %% ../nbs/20_hwc_2node.ipynb 3
from fastcore.utils import *
import pandas as pd
import matplotlib.pyplot as plt
import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import scipy.linalg
import scipy.signal as signal


# %% ../nbs/20_hwc_2node.ipynb 8
class HWC():
  """
  Model of a Hot Water Cylinder using a nodal approach.
  """
  def __init__(self,
              element = 3,        # kW
              T_set = 75,         # °C
              T_deadband = 2,     # °C
              radius =.25,        # m
              height = 1.1,       # m
              U = 0.8,
              noisey = True):
    super(HWC, self).__init__()
    self.U = 0.0019678 #U/60     # 0.5-0.8 kJ/min m2K typical heat transfer losses to ambient  [0.5 kJ/min m2K Jack Paper] kW/m2K
    self.split = np.array([2/3,1/3])
    self.Cv = 4.184 #kJ/kgK
    self.ρ = 1000 #kg/m3
    self.T_ambient = 15 #  Air temperature that the cylinder located in °C
    self.T_cold = 15 # Make up water temperature °C
    self.T_demand = 45 #T_demand - temperature of the end use (shower)  °C
    self.T_deadband = T_deadband #T_deadband  - thermostat deadband °C
    self.T_set = T_set #T_set - thermostat set point °C
    self.element = element # kW = kJ/s
    self.radius = radius
    self.height = height
    self.T_set_bu = 60
    temperature = self.T_set + np.random.uniform(-5, 0)
    if noisey:
      self.temperatures = np.array([temperature,temperature+ np.random.uniform(-5, 0)])
    else:
      self.temperatures = np.array([self.T_set -1, self.T_set-4])
    self.thermostat = np.array([0,0]) # bulk / nodal high / nodal low

    self.UA1 = self.U*(self.A+(2./3.)*self.cylinder_wall_area)/(2*self.A + self.cylinder_wall_area)        #bottom UA
    self.UA2 = self.U*(self.A+(1./3.)*self.cylinder_wall_area)/(2*self.A + self.cylinder_wall_area)        #top UA
    self.C1 = self.volume * (2./3.) * self.ρ * self.Cv                      #bottom
    self.C2 = self.volume * (1./3.) * self.ρ * self.Cv                      #top
    # self._thermostat()
    
  @property
  def surface_area(self): return 2* np.pi * self.radius * self.height + 2 * np.pi * self.radius**2 # m2

  @property
  def volume(self): return np.pi * self.radius ** 2 * self.height  # m3

  @property
  def m(self): return self.split * self.volume * self.ρ # kg

  @property
  def h(self): return self.split * self.height # kg

  @property
  def heat_capacity(self): return self.Cv * self.ρ * self.volume # kJ/K

  @property
  def A(self): return np.pi * self.radius**2 # m2 

  @property
  def cylinder_wall_area(self): return 2* np.pi * self.radius * self.height  # m2 

  @property
  def uas(self): 
    uas = self.split * self.U * self.cylinder_wall_area + self.U * self.A  # unit  heat transfer coefficient kW/K
    return uas #  

  @property
  def k(self): return 1                                        

  @property
  def s1(self): return 1                                        


# %% ../nbs/20_hwc_2node.ipynb 12
@patch
def make_matrix(self:HWC, action = None, flow = None):
    A = np.zeros((2,2))
    action_k = self.k if action == 1 else self.k
    A[0][0] = -(1 / (self.m[0] * self.Cv)) * \
               (action_k * self.A / self.h[0])
    A[0][1] =  (1 / (self.m[0] * self.Cv)) * \
               (action_k * self.A / self.h[0])
    A[1][0] =  (1 / (self.m[1] * self.Cv)) * \
               (action_k * self.A / self.h[1])
    A[1][1] = -(1 / (self.m[1] * self.Cv)) * \
               (action_k * self.A / self.h[1] )

    B= np.zeros((2,3))
    B[0 , 0]   = 0     
    B[1 , 0]   = 0#self.element / (self.m[1]  * self.Cv)     # add element to the bottom node
    B[0 , 1]   = 0#(self.temperatures[1]-self.temperatures[0]) /self.m[0]   
    B[1 , 1]   = 0#(self.T_cold-self.temperatures[1]) /self.m[1]         # add element to the bottom node
    B[0 , 2]   = 0#self.uas[0] / (self.m[0] * self.Cv)   # Energy flow as heat loss to the room from the cylinder wall
    B[1 , 2]   = 0#self.uas[1] / (self.m[1] * self.Cv)   # Energy flow as heat loss to the room from the cylinder wall
    self.B = B

    # for j in range(0,self.nodes-1):
    #     B[j,1] =  flow*self.s1 * self.Cv  * (self.temperatures[j+1] - self.temperatures[j]) # add water flow to the node
    # B[-1,1] =   flow*self.s1 * self.Cv * min(0,(self.T_cold - self.temperatures[-1])) # add cold water flow to the last node

    return A, B

# %% ../nbs/20_hwc_2node.ipynb 13
@patch
def make_matrix(self:HWC, action = None, flow = None):
    A = np.zeros((2,2))

    #state space model matrix construction
    A[0][0] = -(20*self.UA1 + flow * self.Cv) / self.C1
    A[1][0] = flow * self.Cv / self.C2
    A[1][1] = -(20*self.UA2 + flow * self.Cv) / self.C2
        # Ac = np.array([[a00, 0], [a10, a11]], dtype = 'float')
    B= np.zeros((2,4))
    # B[0 , 0]   = 0     
    # B[1 , 0]   = 0     
    # B[0 , 1]   = 0 #self.element / (self.m[1]  * self.Cv)     # add element to the bottom node
    B[1 , 1]   = self.element / self.C1 #self.element / (self.m[1]  * self.Cv)     # add element to the bottom node
    B[0 , 2]   = self.UA1 / self.C1 #(self.temperatures[1]-self.temperatures[0]) /self.m[0]   
    B[1 , 2]   = self.UA2 / self.C2 #(self.T_cold-self.temperatures[1]) /self.m[1]         # add element to the bottom node
    B[0 , 3]   = 0 #self.uas[0] / (self.m[0] * self.Cv)   # Energy flow as heat loss to the room from the cylinder wall
    B[1 , 3]   = flow * self.Cv / self.C1#self.u
        # b00 = self.eta_c * self.element / self.C1
        # b02 = self.UA1 / self.C1
        # b03 = flow * self.Cp / self.C1
        # b11 = self.eta_c * self.WH_P / self.C2
        # b12 = self.UA2 / self.C2
        # Bc = np.array([[b00, 0, b02, b03], [0, b11, b12, 0]], dtype = 'float')
        #create discrete-time state-space system: 


    return A, B
